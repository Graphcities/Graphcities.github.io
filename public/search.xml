<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Luogu P3527「MET-Meteors」解题报告</title>
      <link href="2021/05/26/luogu-p3527met-meteors-jie-ti-bao-gao/"/>
      <url>2021/05/26/luogu-p3527met-meteors-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3527">https://www.luogu.com.cn/problem/P3527</a></p><span id="more"></span><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>有 $n$ 个国家和一个被分为 $m$ 份的环形星球，每一段都属于一个国家（可能相同），还有 $k$ 次事件，每次是星球上 $[l_i,r_i]$ 的顺时针区域的值加上 $a_i$，问你第几次事件之后某个国家的值刚好 $\ge p_i$。$1\le n,m,k\le 3\times 10^5$。<strong>2.50s, 64MB</strong>。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，我们可以对于每个国家进行二分，然后就是一个需要在 $[1,mid], [i,m]$ 的二维数点问题了，主席树解决，时间复杂度 $O(n\log^2n)$，空间也爆掉了。</p><p>那么，我们可不可以，对于每个国家，一起二分呢？</p><p>考虑实现函数 <code>Solve(l,r,L,R)</code>，表示在 $[l,r]$ 范围内处理当前（重排后）的 $[L,R]$ 范围内的国家。我们考虑二分中间值 $mid$，然后执行 $[l,mid]$ 之间的所有询问。执行完后，我们查询 $[L,R]$ 中所有国家，它们在这一段询问后的值 $res$ 是否大于等于 $p_i$。</p><ul><li>如果是的，把它重排到整个 $[L,R]$ 序列之左。</li><li>否则，$p_i$ 的值减去 $res$，重排到 $[L,R]$ 序列之右。</li></ul><p>可以发现，整个序列被分成了两段，左边的答案 $\le mid$，右边的答案 $&gt;mid$，再继续递归下去就可以了。时间复杂度 $O(n\log^2n)$，空间复杂度 $O(n)$，常数小可以通过。</p><p>事实上，这个离线算法叫做 <strong>整体二分</strong>。</p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=q[x].l,r=q[x].r,c=q[x].c*opt;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=r) <span class="built_in">Add</span>(l,c),<span class="built_in">Add</span>(r+<span class="number">1</span>,-c);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">Add</span>(l,c),<span class="built_in">Add</span>(<span class="number">1</span>,c),<span class="built_in">Add</span>(r+<span class="number">1</span>,-c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;R) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,t1=L,t2=R;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=mid;++i) <span class="built_in">Query</span>(i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=L;i&lt;=R;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:v[id[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            res+=<span class="built_in">Count</span>(j);</span><br><span class="line">            <span class="keyword">if</span>(res&gt;=<span class="number">1ll</span>*num[id[i]]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res&gt;=<span class="number">1ll</span>*num[id[i]]) ans[id[i]]=<span class="built_in">min</span>(ans[id[i]],mid),mov[t1++]=id[i];</span><br><span class="line">        <span class="keyword">else</span> num[id[i]]-=res,mov[t2--]=id[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=mid;++i) <span class="built_in">Query</span>(i,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=L;i&lt;=R;++i) id[i]=mov[i];</span><br><span class="line">    <span class="built_in">Solve</span>(l,mid,L,t1<span class="number">-1</span>),<span class="built_in">Solve</span>(mid+<span class="number">1</span>,r,t2+<span class="number">1</span>,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i) v[<span class="built_in">read</span>()].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) num[i]=<span class="built_in">read</span>(),ans[i]=Maxn+<span class="number">5</span>,id[i]=i;</span><br><span class="line">s=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;++i) q[i].l=<span class="built_in">read</span>(),q[i].r=<span class="built_in">read</span>(),q[i].c=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">Solve</span>(<span class="number">1</span>,s,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ans[i]==Maxn+<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;NIE\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 解题报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3466「KLO-Building blocks」解题报告</title>
      <link href="2021/05/25/luogu-p3466klo-building-blocks-jie-ti-bao-gao/"/>
      <url>2021/05/25/luogu-p3466klo-building-blocks-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3466">https://www.luogu.com.cn/problem/P3466</a></p><span id="more"></span><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>给你 $n$ 个数，你可以把每个数 +1/-1，请你用最少的次数使得有 $k$ 个连续的数相同。$1\le n \le 10^5$。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们可以枚举那连续的 $k$ 个数，设为 $a_1,a_2,\cdots,a_k$。学过初一数学的我们都知道，当那个相同的数取中位数时，次数最少。我们设它为 $c$，那么结果为 $|a_1-c|+|a_2-c|+\cdots+|a_k-c|$，分类讨论然后用 <strong>平衡树 / 树状数组</strong> 解决即可。时间复杂度 $O(n\log^2n)$，树状数组常数优秀，卡到最优解。</p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><ul><li>平衡树版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=inf; ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Rank</span>(mid)&gt;=rk) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125; C1=l;</span><br><span class="line">    <span class="keyword">int</span> a,b; <span class="built_in">Split</span>(rt,l,a,b);</span><br><span class="line">    res=<span class="number">1ll</span>*l*(t[a].siz-t[b].siz);</span><br><span class="line">    res=res+t[b].sum-t[a].sum;</span><br><span class="line">    rt=<span class="built_in">Merge</span>(a,b); <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),k=<span class="built_in">read</span>(),rk=(k+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) h[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i) <span class="built_in">Insert</span>(h[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;k) <span class="built_in">Insert</span>(h[i]),<span class="built_in">Delete</span>(h[i-k]);</span><br><span class="line">        ll now=<span class="built_in">Count</span>();</span><br><span class="line">        <span class="keyword">if</span>(now&lt;A) A=now,B=i,C=C1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,A);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(i&gt;B-k &amp;&amp; i&lt;=B)?C:h[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>树状数组版本</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Countt</span>(mid)&gt;=rk) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res=v[l<span class="number">-1</span>]*(<span class="number">2</span>*<span class="built_in">Countt</span>(l)-<span class="built_in">Countt</span>(n));</span><br><span class="line">    res=res+<span class="built_in">Counts</span>(n)-<span class="built_in">Counts</span>(l)*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(res&lt;A) A=res,B=x,C=v[l<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>(),k=<span class="built_in">read</span>(),rk=(k+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) v.<span class="built_in">push_back</span>(h[i]=<span class="built_in">read</span>());</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()),v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()),v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) id[i]=<span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),h[i])-v.<span class="built_in">begin</span>()+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i) <span class="built_in">Addt</span>(id[i],<span class="number">1</span>),<span class="built_in">Adds</span>(id[i],h[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;k) <span class="built_in">Addt</span>(id[i],<span class="number">1</span>),<span class="built_in">Adds</span>(id[i],h[i]),<span class="built_in">Addt</span>(id[i-k],<span class="number">-1</span>),<span class="built_in">Adds</span>(id[i-k],-h[i-k]);</span><br><span class="line">        <span class="built_in">Solve</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,A);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(i&gt;B-k &amp;&amp; i&lt;=B)?C:h[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 解题报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APIO2021 游记</title>
      <link href="2021/05/25/apio2021-you-ji/"/>
      <url>2021/05/25/apio2021-you-ji/</url>
      
        <content type="html"><![CDATA[<blockquote><p>春风暖暖的。它东跑跑，西逛逛，忙个不停。它一吹小草，小草就绿了;一吹小花，小花就开了;一吹柳丝，柳丝就露出了嫩芽。哦，春风是画家，是它染绿了大地;春风是魔术师，是它变出了盛开的百花。看，这会儿，它又在和柳丝舞蹈、和小花玩耍呢。<br><span id="more"></span><br>春雨甜甜的。它让万物苏醒，焕发勃勃生机。竹笋喝后，就从土里迫不急待地冒出地面，它好像非常渴望光明，再也不愿待在黑暗的世界。百花喝后，开得更娇艳了，它们在风中欢快地跳舞，像是在向春雨致谢呢。万木喝后，长得越来越高、越来越壮，像一个个哨兵站得更笔直了。瞧，孩子们正在雨中奔跑、玩耍，还撒下了一路欢声笑语。真是一个快乐的春天!</p><p>春使靓靓的。植物王国的春使是迎春花，黄色的小花露出笑脸，带花的枝条像小姑娘时髦的发辫。动物王国的春使是燕子，它们斜着身子在空中掠过，唧唧地叫着，传递着春的消息。当人们看到迎春花开、燕子归来，就知道春姑娘来了。</p><p>春天，又到了考 APIO 的季节！</p></blockquote><hr><h3 id="Day-N"><a href="#Day-N" class="headerlink" title="Day -N"></a>Day -N</h3><blockquote><p>对人们来说，春天是一年的开始，也象徵着新的希望。农夫忙着犁田，插秧，学生准备开学用品，希望今年有个好的开始，就如同洒下的种子般，能够成功的发芽，开花，结果，不论有任何困难，都要勇敢面对。也因为人们是这麽去思考的，所以春天才象徵着新希望。</p></blockquote><p><del>发现自己不会写数据结构了</del></p><p>每天听课轮番轰炸后直接下线，<del>san 值狂掉</del></p><p>好像三道题都是交互题，完了，我一道交互没做</p><p>听说可以开卷？！那万一有原题是不是可以直接抄题解？！（然而真中了）</p><hr><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><blockquote><p>春是什么？春是那明月清风，柔媚清朗，在苔痕映照的静寂林间，清冽缠绵的旋律翩然飘临，希望伴着歌声在阳光中冉冉升起。春是那淡雨疏风，薄雾浓云，笼住水边清香的荫影，生命在这朦胧凄迷的氛围中孕育而生。</p></blockquote><p>开考前 10min 几乎把自己毕生所学的所有模板全都复制了下来，<del>后来发现一个都没用到</del></p><p>因为有 IOI 赛制，开考很愉快。</p><p>但是由于学校机房太烂没有 C++17 交互题只能够手写交互库差评。</p><ul><li><strong>前 20min</strong></li></ul><blockquote><p>万物在春晨中醒来，展示着生命的可贵、诱人。</p></blockquote><p>看题去了</p><p>第一题，smg，直接跳过。</p><p>第二题，感觉是一个有点意思的图论题，应该可以骗点分。</p><p>第三题，发现有点像奇奇怪怪的网络流 / 树形dp，但总比第一题好一点。</p><p>开题顺序：2 $\to$ 3 $\to$ 1</p><ul><li><strong>接下来的 1h</strong></li></ul><blockquote><p>春晨点染心中的希望，激发着人生的热情。</p></blockquote><p>做第二题的暴力去了。</p><p>前面五次提交基本都在试交互题怎么写。</p><p>由于这是 IOI 赛制，而且每个子任务按照最高分计算，暴力还是挺好打的。</p><p>前面三个子任务直接单调栈暴力建图，然后 bfs $O(n^2)$，37pts 到手！<del>但没想到这样就有 Cu。</del></p><ul><li><strong>接下来的又 1h</strong></li></ul><blockquote><p>春是活泼的、春是狂热的、春是姿意生长的、春是年青旺盛的。</p></blockquote><p>做第三题的暴力去了。</p><p>只会写排序和简单 dp 的我甚至连 $O(n^2)$ 的部分分都不会。12pts。</p><ul><li><strong>接下来的所有时间</strong></li></ul><blockquote><p>田野里、花园里和森林里都有着春姑娘留下足迹，她把大地装饰得美丽、祥和。</p></blockquote><p>APIO 有印尼宽带和土豆服务器的加持，网速真是太快了！很快就到他家门口！</p><p>APIO 第一次创立了 IOIOI 赛制！</p><p>预计得分：0+37+12=49pts</p><p>实际得分：0+37+12=49pts</p><p>扫雷真快乐！小恐龙真快乐！</p><ul><li><strong>感想</strong></li></ul><blockquote><p>没有春的万紫千红？哪来秋的硕果累累？</p></blockquote><p>成功的地方：</p><p>铜牌一枚，扫雷过关，小恐龙玩的很开心，第一次体验印尼宽带的魅力很好玩，旁边就是 iodwad 巨佬</p><p>不足的地方：</p><p>扫雷在最后几步挂掉，小恐龙刚到 1000 分就被撞，没有充足的休息时间</p><hr><h3 id="Day-N-1"><a href="#Day-N-1" class="headerlink" title="Day N"></a>Day N</h3><blockquote><p>柳树舒展开了黄绿嫩叶的枝条，在微微的春风中轻柔地拂动，就像一群群身着绿装的仙女在翩翩起舞。夹在柳树中间的桃树也开出了鲜艳的花朵，绿的柳，红的花，真是美极了！</p></blockquote><p>第一题第二题第三题依旧不会。</p><p>我成为了时代的眼泪</p><hr><blockquote><p>春姑娘，你在哪儿呢？在和我们玩捉迷藏吗？我们找呀找呀。忽然听见一阵“叽叽”的叫声，抬头一看，原来是一群活泼可爱的小燕子，它们拖着剪刀似的小尾巴，排着整齐的队伍，从北方飞回到久别的故乡——南方。它们一边拍打着翅膀，一边欢快地叫着，仿佛在说“春天来了，春天来了!”是的，春天真的来了!我情不自禁地对小燕子大喊道：“春姑娘，你好，我找到你了!” </p><p>告别了小燕子，我们来到草地上寻找春姑娘。嫩绿的小草已经探出了小脑袋，那是春天的眉毛吧！一阵春风吹来，小草随着风摇摆起来，好像在风里快乐地翩翩起舞。它们有的舒展开自己的双臂，有的弯下腰，有的摇头晃脑……瞧它们跳得多开心啊！还有各种各样的奇花异草都赶到这里来聚会。它们颜色各异，群芳吐艳，有的几十朵连在一起，一丛丛、一簇簇，真像一群团结友善的小朋友。看见这情景，我不禁脱口而出：“春姑娘，我找到你了，你多美丽呀！” </p><p>就在这时，天空突然飘下丝丝细线。“咦！这是什么，那么细，那么密！像牛毛，像银针。”我们伸出双手，悄悄接住这“细细的线”，只见它落在我们的手心，凉凉的，润润的。用舌尖轻轻一舔，有股甜甜的味道，不再有寒意，也不再刺骨。都说“春雨贵如油”，还真是呀！这蒙蒙的细雨落在小草上，草儿们争先恐后地伸长着脖子不断地吮吸着。花儿们则张开笑脸，变得更加娇羞欲滴。“找到了，找到了，春姑娘真的来到了我们的身边！”我们张开双臂欢呼着。 </p><p>APIO2021，就像春天一样到来了！</p></blockquote><p>首 尾 呼 应，升 华 主 题，点 明 中 心</p><hr><p>再 次 加 更</p><h3 id="生活在-APIO2021-上"><a href="#生活在-APIO2021-上" class="headerlink" title="生活在 APIO2021 上"></a>生活在 APIO2021 上</h3><blockquote><p>现代计算机科学以CCF的“做干净的奥赛”为嚆矢。滥觞于哲学与数学的期望正失去它们的借鉴意义。但面对看似无垠的未来天空，我想循老K“好的代码本身就是最好的文档。当你打算加注释的时候，问问自己“我如何改善代码以至于不需要注释？””好过过早地振翮。</p><p>我们怀揣热忱的灵魂天然被赋予对超越性的追求，不屑于古旧坐标的约束，钟情于在别处的芬芳。但当这种期望流于对IOIOI主义不假思索的批判，乃至走向印尼宽带与ssh主义时，便值得警惕了。与秩序的落差、错位向来不能为越矩的行为张本。而纵然我们已有翔实的蓝图，仍不能自持已在浪潮之巅立下了自己的沉锚。</p><p>“任何计算机科学领域的问题都能通过ssh来解决。然而这通常会带来其他问题。”AKssh5307之言可谓切中了肯綮。人的突发性性是不可祓除的，而我们欲上青云也无时无刻不在因风借力。数学与哲学暂且被我们把握为一个薄脊的符号客体，一定程度上是因为我们尚缺乏体验与阅历去支撑自己的认知。而这种偏见的傲慢更远在知性的傲慢之上。</p><p>在孜孜矻矻以求计算机科学意义的道路上，对自己的期望本就是在与数学与哲学对接中塑型的动态过程。而我们的底料便是对不同暴力、不同倍增的觉感与体认。NOI为杜子德送去计算几何，又维系SSH。他的计算机科学观念是厚实的，也是实践的。倘若我们在对过往借Qiuly之言“祓魅”后，又对不断膨胀的自我进行“赋魅”，那么在丢失外界预期的同时，未尝也不是丢了自我。</p><p>毫无疑问，从哲学与数学角度一觇的自我有偏狭过时的成分。但我们所应摒弃的不是对此的批判，而是其批判的廉价，其对批判投诚中的反智倾向。在zaixianmojulao的观念中，如果在成为狮子与孩子之前，略去了像骆驼一样背负前人遗产的过程，那其“永远重复”洵不能成立。</p><p>蓝图上的落差终归只是理念上的区分，在实践场域的分野也未必明晰。譬如当我们追寻模板时，在途中涉足网络流，这究竟是伴随着期望的泯灭还是期望的达成？在我们塑造计算机科学的同时，计算机科学也在浇铸我们。既不可否认原生的网络流畅性与时效性性，又承认自己的图景有轻狂的失真，不妨让体验走在言语之前。用不被禁锢的头脑去体味CCF_NOI的大海与风帆，并效huhao，对无法言说之事保持沉默。</p><p>用在APIO2021上的生活方式体现个体的超越性，保持婞直却又不拘泥于所谓“遗世独立”的单向度形象。这便是Qiuly为我们提供的理想期望范式。生活在APIO2021上——始终热爱大地——升上天空。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫比乌斯反演技巧</title>
      <link href="2021/05/17/mo-bi-wu-si-fan-yan-ji-qiao/"/>
      <url>2021/05/17/mo-bi-wu-si-fan-yan-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p>（ 暂未完结 ）</p><p><strong>莫比乌斯反演</strong> 是数论中比较难但也比较基础的内容，通常考验选手们的推式子能力。所以，推式子的技巧，包括交换和式，二维数论分块，换元法 $\cdots\cdots$ 都是很重要的内容。在这篇文章中，我们通过几个例题，来探究这些 “奇奇怪怪” 的技巧。</p><span id="more"></span><hr><ul><li>交换和式 - <a href="https://www.luogu.com.cn/problem/P2522">P2522 HAOI2011 Problem b</a></li></ul><script type="math/tex; mode=display">\begin{aligned}& \sum_{i=1}^n\sum_{j=1}^m [\gcd(i,j)=k ] \\= \ & \sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{k}\rfloor}[\gcd(i,j)=1] \\= \ & \sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{k}\rfloor}\sum_{d|\gcd(i,j)}\mu(d) \\= \ & \sum_{i=1}^{\lfloor \frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{k}\rfloor}\sum_{d|i,d|j}\mu(d) \\= \ & \color[RGB]{33,150,243}{\sum_{d=1}^{\min(\lfloor \frac{n}{k}\rfloor,\lfloor \frac{m}{k}\rfloor)}\mu(d)\sum_{i=1}^n[d\mid i]\sum_{j=1}^n[d\mid j]} \\= \ & \sum_{d=1}^{\min(\lfloor \frac{n}{k}\rfloor,\lfloor \frac{m}{k}\rfloor)}\mu(d)\lfloor\frac{n}{kd}\rfloor\lfloor\frac{m}{kd}\rfloor\end{aligned}</script><p>然后预处理莫比乌斯函数前缀和，数论分块求解即可。单次 $O(\sqrt{n})$。</p><hr><ul><li>二维数论分块 - <a href="https://www.luogu.com.cn/problem/P1829">P1829 国家集训队 Crash的数字表格</a></li></ul><script type="math/tex; mode=display">\begin{aligned}& \sum_{i=1}^n\sum_{j=1}^m\operatorname{lcm}(i,j)\\=\ & \sum_{i=1}^n\sum_{j=1}^m\frac{i\times j}{\gcd(i,j)}\\=\ & \sum_{d=1}^n\frac{1}{d}\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)=d]\\=\ & \sum_{d=1}^nd\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[\gcd(i,j)=1]\end{aligned}</script><p>我们设 $f(a,b)=\sum_{i=1}^a\sum_{j=1}^b[\gcd(i,j)=1]$，考察一下这个函数：</p><script type="math/tex; mode=display">f(a,b)=\sum_{d=1}^{\min(a,b)}\mu(d)\lfloor\frac{a}{d}\rfloor\lfloor\frac{b}{d}\rfloor</script><p>然后我们发现这个东西可以数论分块。此时原式等于</p><script type="math/tex; mode=display">\color[RGB]{33,150,243}{\sum_{d=1}^ndf(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}</script><p>发现它又可以数论分块，那么总时间复杂度就变成了 $O(\sqrt{n}\times\sqrt{n})=O(n)$。</p><hr><ul><li>欧拉函数优化问题 - <a href="https://www.luogu.com.cn/problem/P5221">P5221 Product</a></li></ul><script type="math/tex; mode=display">\begin{aligned}& \prod_{i=1}^n\prod_{j=1}^n\frac{\operatorname{lcm}(i,j)}{\gcd(i,j)}\\=\ & \prod_{i=1}^n\prod_{j=1}^n\frac{i\times j}{\gcd(i,j)^2}\\=\ & (n!)^{2n}\times \frac{1}{f(n)}\ (f(n)=\prod_{i=1}^n\prod_{j=1}^n{\gcd(i,j)^2})\end{aligned}</script><p>我们来转化一下 $f(n)$：</p><script type="math/tex; mode=display">\begin{aligned}& \prod_{i=1}^n\prod_{j=1}^n{\gcd(i,j)^2}\\=\ & \prod_{d=1}^n(d^2)^{\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=d]}\end{aligned}</script><p>我们来看看 $\sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=d]$，发现它是一个莫比乌斯函数的经典式子，但需要二维数论分块，时间复杂度 $O(n)$，太高，而且空间也不够，所以我们来用另一种方法转化这个式子：</p><script type="math/tex; mode=display">\begin{aligned}& \sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=d]\\=\ & \sum_{i=1}^s\sum_{j=1}^s[\gcd(i,j)=1] \ (s=\lfloor\frac{n}{d}\rfloor)\\=\ & \sum_{1\le j\le i \le s}[\gcd(i,j)=1]+\sum_{1\le i\le j\le s}[\gcd(j,i)=1]-\sum_{i=1}^s[\gcd(i,i)=1] \\=\ & \color[RGB]{33,150,243}{-1+2\sum_{i=1}^s\varphi(i)}\end{aligned}</script><p>如果处理 $\varphi(i)$ 前缀和就可以 $O(1)$ 解决，总时间复杂度就变成了 $O(\sqrt{n})$。</p><hr><ul><li>利用 $\gcd$ 函数性质 - <a href="https://www.luogu.com.cn/problem/SP5971">SP5971 LCMSUM</a></li></ul><script type="math/tex; mode=display">\begin{aligned}& \sum_{i=1}^n\operatorname{lcm}(n,i) \\= \ & \sum_{i=1}^n\frac{n\times i}{\gcd(n,i)}\end{aligned}</script><p>利用 $\gcd(n,i)=\gcd(n,n-i)$ 的性质，可以得到</p><script type="math/tex; mode=display">\begin{aligned}& n+\frac{1}{2}\sum_{i=1}^{n-1}\frac{n^2}{\gcd(n,i)} \\= \ & \frac{n}{2}+\frac{1}{2}\sum_{i=1}^{n}\frac{n^2}{\gcd(n,i)} \\= \ & \frac{n}{2}+\frac{1}{2}\sum_{d=1}^n\frac{n^2}{d}\sum_{i=1}^{n-1}[\gcd(n,i)=d] \\= \ & \color[RGB]{33,150,243}{\frac{n}{2}+\frac{1}{2}\sum_{d|n}\frac{n^2\varphi(\frac{n}{d})}{d}}\end{aligned}</script><p>我们再设 $k=\dfrac{n}{d}$，可以得到</p><script type="math/tex; mode=display">\begin{aligned}& \frac{n}{2}+\frac{1}{2}\sum_{d|n}nk\times\varphi(k)\\= \ & \frac{n}{2}(1+\sum_{d|n}k\times \varphi(k))\end{aligned}</script><p>可以发现下面的式子是个积性函数，预处理后总时间复杂度 $O(1)$。</p><hr><ul><li>换元法 - <a href="https://www.luogu.com.cn/problem/P2257">P2257 YY的GCD</a></li></ul><script type="math/tex; mode=display">\begin{aligned}& \sum_{i=1}^n\sum_{j=1}^m\operatorname{isprime}(\gcd(i,j))\\= \ & \sum_{p\le n}\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)=p]\ (\operatorname{isprime(p)}=1) \\= \ & \sum_{p\le n}\sum_{d=1}^{\lfloor\frac{n}{p}\rfloor}\mu(d)\lfloor\frac{n}{dp}\rfloor\lfloor\frac{m}{dp}\rfloor\end{aligned}</script><p>我们设 $k=dp$，换元，得到</p><script type="math/tex; mode=display">\begin{aligned}\color[RGB]{33,150,243}{\sum_{k=1}^n\lfloor\frac{n}{k}\rfloor\lfloor\frac{m}{k}\rfloor\sum_{p|k}\mu(\frac{k}{p})}\end{aligned}</script><p>我们发现后面那个式子可以埃氏筛，前面则可以数论分块，时间复杂度 $O(\sqrt{n})$。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈排列组合 1</title>
      <link href="2021/05/17/qian-tan-pai-lie-zu-he-1/"/>
      <url>2021/05/17/qian-tan-pai-lie-zu-he-1/</url>
      
        <content type="html"><![CDATA[<h2 id="浅谈排列组合"><a href="#浅谈排列组合" class="headerlink" title="浅谈排列组合"></a>浅谈排列组合</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>排列组合</li></ul><script type="math/tex; mode=display">A^m_n= \frac{n!}{(n-m)!} \\\binom{n}{m}=C^m_n=\frac{A^m_n}{A^m_m}=\frac{n!}{(n-m)! \cdot m!}</script><p>特别的，当 $m&gt;n$ 时，$C^m_n=0$ 。</p><span id="more"></span><ul><li>排列组合的推导</li></ul><p>在 $n$ 个数里面 <strong>按顺序</strong> 的选择 $m$ 个数，也就是 $A^m_n$ ，我们可以这样假设：有 $m$ 个空位，你需要一一把这 $n$ 个物品放上去。有 $n$ 种选择可以在第一个空位上面（ 因为每一个物品都可以放上去 ）。而第二个空位只有 $n-1$ 种选择，（因为有一个物品已经放在了第一个空位，剩下了 $n-1$ 个物品），第三个空位只有 $n-2$ 种选择 $\cdots\cdots$ ，第 $m$ 个空位只有 $(n-m+1)$ 中选择。所以，$A^m_n=n\times(n-1)\times\cdots\times(n-m+1)=\dfrac{n!}{(n-m)!}$ 。</p><p>在 $n$ 个数里面 <strong>不按顺序</strong> 的选择 $m$ 个数，也就是 $C^m_n$ ，也可以写成 $\binom{n}{m}$ 。如果在乎顺序选择，那么总结果就是 $A^m_n$ 。如果不在乎顺序，就要去掉重复。所有被选出来的 $m$ 个数，按顺序排列有 $A^m_m$ 种，如果不按顺序排列，就只有一种。所以，$C^m_n=\dfrac{A^m_n}{A^m_m}=\dfrac{n!}{(n-m)! \cdot m!}$ 。</p><ul><li>排列组合的扩充</li></ul><p>由定义，我们可以发现 $n$ 个数里面选取 $m$ 个数的方案跟 $n$ 个数里面选取 $n-m$ 个数的方案是一样的（因为 $n$ 个数里面选 $m$ 个数，就相当于在 $n$ 个数里面选择 $n-m$ 个数丢掉），于是我们可以得到：</p><script type="math/tex; mode=display">\binom{n}{m}=\binom{n}{n-m}</script><p>当在 $n+m$ 个数里面选择 $m$ 个数（ $n \ge m$ ）的时候，相当于从 $n$ 个数里面选择 $0,1,2,\cdots,m$ 个数，并且在剩下 $m$ 个数里面选 $m,m-1,m-2,\cdots,0$ 个数的方案数之和。也就是说，</p><script type="math/tex; mode=display">\sum_{i=0}^m\binom{n}{i}\binom{m}{m-i}=\binom{n+m}{m}</script><p>其中 $\sum$ 是求和符号，表示 $i=0,1,2,3,\cdots,m$ 时，求和符号右边式子的值的和。</p><p>当 $n=m$ 时，我们还可以得出</p><script type="math/tex; mode=display">\sum_{i=0}^n\binom{n}{i}^2=\binom{2n}{n}</script><hr><h3 id="1-组合数的递推式"><a href="#1-组合数的递推式" class="headerlink" title="1. 组合数的递推式"></a>1. 组合数的递推式</h3><p>在这一节，我们将会证明这个公式：</p><script type="math/tex; mode=display">\binom{a}{b}=\binom{a-1}{b-1}+\binom{a-1}{b}</script><ul><li>由 <strong>定义</strong> 出发</li></ul><p>先来看看 $\binom{a}{b}$ 的含义。它指的就是从 $a$ 个数里面不按顺序选出 $b$ 个数的方案数。</p><p>我们可以这样分类讨论：</p><ol><li><p>不选最后一个数，那么就要从 $(a-1)$ 个数里面选出 $b$ 个，即 $\binom{a-1}{b}$ 。</p></li><li><p>选最后一个数，那么只要从 $(a-1)$ 个数里面选 $(b-1)$ 个数即可，那么就是 $\binom{a-1}{b-1}$ 。</p></li></ol><p>由加法原理可以得到</p><script type="math/tex; mode=display">\binom{a}{b}=\binom{a-1}{b-1}+\binom{a-1}{b}</script><ul><li>由 <strong>计算</strong> 出发</li></ul><script type="math/tex; mode=display">\begin{aligned}&\binom{a-1}{b-1}+\binom{a-1}{b} \\&= \frac{(a-1)!}{(a-b)! \cdot (b-1)!}+\frac{(a-1)!}{(a-b-1)!\cdot b!} \\&= \frac{(a-1)(a-2)\cdots(a-b+1)}{(b-1)!}+ \frac{(a-1)(a-2)\cdots(a-b)}{b!}\end{aligned}</script><p>提公因式 $(a-1)(a-2)\cdots(a-b+1)$，得原式</p><script type="math/tex; mode=display">\begin{aligned}&=(a-1)(a-2)\cdots(a-b+1) \cdot ( \frac{1}{(b-1)!} +\frac{a-b}{b!} )\\&= (a-1)(a-2)\cdots(a-b+1) \cdot ( \frac{b}{b!} +\frac{a-b}{b!} )\\&= (a-1)(a-2)\cdots(a-b+1) \cdot \frac{a}{b!}\\&= \frac{a(a-1)(a-2)\cdots(a-b+1)}{b!}\\&= \frac{a!}{(a-b)! \cdot b!}=\binom{a}{b}\\&& \square\end{aligned}</script><blockquote><p>关于证明最后的小方块：QED 是拉丁词组 <strong>Q</strong>uod <strong>E</strong>rat <strong>D</strong>emonstrandum（这就是所要证明的）的缩写，代表证明完毕。现在的 QED 符号通常是 $\blacksquare$ 或者是 $\square$。—— <a href="https://oi-wiki.org/math/mobius/">OI-Wiki</a></p></blockquote><hr><h3 id="Ex-1-二项式定理"><a href="#Ex-1-二项式定理" class="headerlink" title="Ex.1 二项式定理"></a>Ex.1 二项式定理</h3><p>我们先从完全平方公式说起：</p><script type="math/tex; mode=display">(a+b)^2=a^2+2ab+b^2</script><p>那么， $(a+b)^n$ 该怎么求呢？在这一节，我们将会证明这个公式，也就是 <strong>二项式定理</strong>：</p><script type="math/tex; mode=display">\begin{aligned}(a+b)^n&=\binom{n}{0}a^0b^n+\binom{n}{1}a^1b^{n-1}+\cdots+\binom{n}{n}a^nb^0\\&=\sum_{i=0}^n\binom{n}{i}a^ib^{n-i}\end{aligned}</script><p>其中 $\sum$ 是求和符号，表示 $i=0,1,2,3,\cdots,n$ 时，求和符号右边式子的值的和。</p><p><strong>证明：</strong> 考虑 <strong>数学归纳法</strong>，</p><p>当 $n=0$ 时，$(a+b)^0=1\times a^0b^0=1$ 显然成立。</p><p>假设当 $n=k$ 时成立，即 $(a+b)^k=\sum_{i=0}^k\binom{k}{i}a^ib^{k-i}$ 。那么，当 $n=k+1$ 时，</p><script type="math/tex; mode=display">\begin{aligned}(a+b)^{k+1}&=(a+b)^k\times(a+b)\\&=(a+b)\times(\binom{k}{0}b^k+\binom{k}{1}a^1b^{k-1}+\cdots+\binom{k}{k}a^k)\\&=\binom{k}{k}a^{k+1}+\binom{k}{k-1}a^kb+\binom{k}{k-2}a^{k-1}b^2+\cdots+\binom{k}{0}ab^k\\&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ +\binom{k}{k}a^kb\ \ \ \ \ \ \ +\binom{k}{k-1}a^{k-1}b^2+\binom{k}{k-2}a^{k-2}b^3+\cdots+\binom{k}{0}b^{k+1}\\&=\binom{k}{k}a^{k+1}+(\binom{k}{k}+\binom{k}{k-1})a^kb+(\binom{k}{k-1}+\binom{k}{k-2})a^{k-1}b^2+\cdots+\binom{k}{0}b^{k+1}\\&=\binom{k+1}{k+1}a^{k+1}+\binom{k+1}{k}a^kb+\binom{k+1}{k-1}a^{k-1}b^2+\cdots+\binom{k}{0}b^{k+1}\\&=\sum_{i=0}^{k+1}\binom{k+1}{i}a^ib^{k+1-i}\\&&\square\end{aligned}</script><p>如果你不想看到这么复杂的计算过程，你也可以从它的组合意义出发，<a href="https://www.zhihu.com/collection/449573449">证明在这里</a>。</p><p>当二项式定理中的 $a$ 和 $b$ 取特殊值时，你可以得到下面这些式子：</p><script type="math/tex; mode=display">\begin{aligned}\binom{n}{0}+\binom{n}{1}+\cdots+\binom{n}{n}=2^n &&(a=b=1)\\\sum_{i=0}^n(-1)^i\binom{n}{i}=0 &&(a=-1,b=1) \\\end{aligned}</script><hr><h3 id="2-杨辉三角与排列组合"><a href="#2-杨辉三角与排列组合" class="headerlink" title="2. 杨辉三角与排列组合"></a>2. 杨辉三角与排列组合</h3><p>先将杨辉三角集体左移，放在一张表格上。（ 注意表格的行 / 列开头是 <strong>0</strong> ）</p><div class="table-container"><table><thead><tr><th style="text-align:center">行 / 列</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th></tr></thead><tbody><tr><td style="text-align:center"><strong>0</strong></td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>1</strong></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>2</strong></td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>3</strong></td><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>4</strong></td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">6</td><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>5</strong></td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">10</td><td style="text-align:center">10</td><td style="text-align:center">5</td><td style="text-align:center">1</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>6</strong></td><td style="text-align:center">1</td><td style="text-align:center">6</td><td style="text-align:center">15</td><td style="text-align:center">20</td><td style="text-align:center">15</td><td style="text-align:center">6</td><td style="text-align:center">1</td></tr></tbody></table></div><p>我们设表格中第 $x$ 行，第 $y$ 列的数是 $P(x,y)$ 。</p><p>首先，由杨辉三角本身可以得到 $P(a,b)=P(a-1,b)+P(a-1,b-1)$ 。</p><p>接着，我们可以发现一个比较神奇的事实：$P(a,b)=\binom{a}{b}$ 。</p><p><strong>证明</strong>：考虑 <strong>数学归纳法</strong>，</p><p>显然可得 $P(0,0)=\binom{0}{0}$ 。</p><p>发现杨辉三角的递推式 $P(a,b)=P(a-1,b)+P(a-1,b-1)$<br>与组合数的递推式 $\binom{a}{b}=\binom{a-1}{b-1}+\binom{a-1}{b}$ 形式是相同的，由此可以判断下列等式成立：</p><script type="math/tex; mode=display">P(a,b)=\binom{a}{b}</script><p>我们再来回顾一下二项式定理：</p><script type="math/tex; mode=display">(a+b)^n= \sum_{i=0}^{n} \dbinom{n}{i}a^i b^{n-i}</script><p>将它的系数从前往后列出来：$\dbinom{n}{0},  \dbinom{n}{1} ,  \dbinom{n}{2} ,  \cdots ,  \dbinom{n}{n}$</p><p>由 $P(a,b)=\dbinom{a}{b}$ 可以得到：这些数字刚好就是杨辉三角第 $n$ 行从前往后的数字！</p><p>而这，就是杨辉三角和组合数之间的关系。</p><hr><h3 id="Ex-2-Catalan-数"><a href="#Ex-2-Catalan-数" class="headerlink" title="Ex.2 Catalan 数"></a>Ex.2 Catalan 数</h3><p>假如你在一个平面直角坐标系上，起点为 $(0,0)$ 。你一共可以移动 $2n$ 次，每次可以向右或向上走一格。我们规定，你在任意时刻往右走的次数都不能少于往上走的次数。问：当你走到点 $(n,n)$ 时，有多少种不同的路径？</p><p>如果不按照规定来，方案则相当于在 $2n$ 次移动中选择 $n$ 次向上移动，总数为$\dbinom{2n}{n}$ 。</p><p>所有方案总数求出来了，我们接下来想一想不符合规定的方案总数。<br>先来想一个问题，什么时候方案是不符合要求的？</p><p>设你在移动若干次后的坐标为 $(a,b)$ , 根据 ”你在任意时刻往右走的次数都不能少于往上走的次数“ 这一规定，可以得到这个不等式：$a \geq b$ 。也就是说，<strong>我们在坐标系上，把 $y=x+1$ 这条线画出来，如果一条路径触碰到了这根线，它就不符合要求。</strong></p><p>这种方案就是不符合要求的：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/wzlqalyl.png" alt=""></p><p>我们再尝试对这个不符合要求的方案转换一下：</p><p>所有的不符合要求的路径，都或多或少的触碰到了 $y=x+1$ 这一条直线。我们把第一次触碰到这条直线时的坐标记为 $(a,b)$ 。</p><p>我们再把 $(a,b)$ 之后的路径全都按照 $y=x+1$ 这条直线对称过去，此时图片变成了这样：<br>（ 黑色：原路径     蓝色：对称后路径 ）</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4nnopfuo.png" alt=""></p><p>对称过后，终点坐标就变成了 $(n-1,n+1)$ 。而且，所有不符合规定的路径对称后就唯一对应着一条到 $(n-1,n+1)$ 的路径。不仅如此，<strong>所有到 $(n-1,n+1)$ 的一条路径也都唯一对应着一条不符合规定的路径</strong> 。（ 只需要再次对称回去就行了 ）从点 $(0,0)$ 到点 $(n-1,n+1)$ 的一条路径方案就相当于在 $2n$ 次移动操作中选取 $n+1$ 次的向上操作，总数为 $\binom{2n}{n+1}$ 。</p><p>那么，所有符合规定的路径方案总数为 $\dbinom{2n}{n} - \dbinom{2n}{n+1}$ 。</p><p>又因为 $\dbinom{a}{b} = \dbinom{a}{a-b}$ ，方案总数还可以表示为 $\dbinom{2n}{n} - \dbinom{2n}{n-1}$ 。</p><p>而这，就是 <strong>Catalan 数</strong> 的通项公式。这个问题只是 Catalan 数的一种形式。</p><hr><h3 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h3><ol><li>求证： $\sum_{i=0}^n\binom{n-i}{i}=F_{n+1}$ ，其中 $F$ 指斐波那契数列。</li></ol><p><strong>证明</strong>：考虑 <strong>数学归纳法</strong>，</p><p>当 $n=0$ 时，$\dbinom{0}{0}=F_1=1$ 显然成立。当 $n=k$ 时，</p><script type="math/tex; mode=display">\begin{aligned}F_k+F_{k-1}&=\sum_{i=0}^k\binom{k-i}{i}+\sum_{i=0}^{k-1}\binom{k-1-i}{i} \\&=\binom{k}{0}+\binom{k-1}{1}+\binom{k-2}{2}+\binom{k-3}{3}+\cdots+\binom{1}{k-1}+\binom{0}{k}\\&\ \ \ \ \ \ \ \ \ \ \ \ \ \ +\binom{k-1}{0} +\binom{k-2}{1}+\binom{k-3}{2}+\cdots+\binom{1}{k-2}+\binom{0}{k-1}\\&=\binom{k+1}{0}+\binom{k}{1}+\binom{k-1}{2}+\cdots+\binom{2}{k-1}+\binom{1}{k}+\binom{0}{k+1}\\&=\sum_{i=1}^{k+1}\binom{k+1-i}{i}=F_{k+1}\\&&\square\end{aligned}</script><ol><li><a href="https://www.luogu.com.cn/problem/P6870"><strong>Zapina</strong></a> / 有 $n$ 个不同的人和 $n$ 道不同的题，当第 $i$ 个人开心时，当且仅当他被分配到 $i$ 道题。请求出让至少一个人开心的方案数。</li></ol><p><strong>答案 = 总方案数 - 所有人都不开心的方案数</strong> </p><p>对于每道题而言，它都有 $n$ 个选择来去到一个人的手中。而又有 $n$ 道互不相同的题，根据乘法原理，所有总方案数自然就是 $n^n$ 。我们设 $f(i,j)$ 为到了第 $i$ 个人，分配了 $j$ 道题目后都不开心的方案数，易得</p><script type="math/tex; mode=display">f(i,j)=\sum_{k=0}^j f(i-1,k)\times \binom{j}{k} \times [k\not=i]</script><p>其中 $[k\not=i]$ 表示判断语句。当语句内容为真时，值为 1。如果为假，值为 0。<br>初始值 $f(0,0)=0$ ，终值为 $f(n,n)$ ，答案即为 $n^n-f(n,n)$ 。</p><p><a href="https://www.luogu.com.cn/paste/0chfntrh"><strong>Python 伪代码</strong></a> / <a href="https://www.luogu.com.cn/paste/yu31fw9x"><strong>C++ 关键代码</strong></a></p><ol><li><a href="https://loj.ac/p/6513"><strong>「雅礼集训2018」足球大战</strong></a> / 有一场足球比赛，还有 $n$ 秒就结束了，比分还是 $0:0$ 。主队每秒进球概率为 $p$ ，客队每秒进球概率为 $q$ ，求主队的获胜概率。</li></ol><p>我们设 $T(i,j)$ 为队伍 $i$ （ $i=1$ 表示主队，$i=0$ 表示客队 ）进球 $j$ 次的概率。可以得到</p><script type="math/tex; mode=display">P(\text{win})=\sum_{i=1}^nT(1,i)\sum_{j=0}^{i-1}T(0,j)</script><p>我们还可以得到，</p><script type="math/tex; mode=display">T(i,j)=\begin{cases}p^j(1-p)^{n-j}\times\dbinom{n}{j} & (i=1) \\ q^j(1-q)^{n-j}\times\dbinom{n}{j} & (i=0)\end{cases}</script><p>我们又设 $S(k)=\sum_{i=0}^kT(0,i)$ ，可以得到如下递推式：</p><script type="math/tex; mode=display">S(0)=T(0,0),\ S(n)=S(n-1)+T(0,n) \ (n\ge 1)</script><p>最后，再把这些式子整合在一起，可以得到</p><script type="math/tex; mode=display">P(\text{win})=\sum_{i=1}^nT(1,i)\times S(i-1)</script><p>这里给出此题的 <a href="https://loj.ac/s/969480"><strong>C++ 正解代码</strong></a> 。</p><hr><h3 id="All-In-All"><a href="#All-In-All" class="headerlink" title="All In All"></a>All In All</h3><p>我们学到了什么？</p><ul><li>排列组合的定义，计算和拓展</li><li>二项式定理的公式和拓展</li><li>杨辉三角和排列组合的关系</li><li>Catalan 数</li><li><strong>数学归纳法</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3396「哈希冲突」解题报告</title>
      <link href="2021/05/16/luogu-p3396ha-xi-chong-tu-jie-ti-bao-gao/"/>
      <url>2021/05/16/luogu-p3396ha-xi-chong-tu-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3396">https://www.luogu.com.cn/problem/P3396</a></p><span id="more"></span><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>对于一个 $n$ 个数的数组 $a$ 和 $m$ 个询问，询问有以下种类：（ $1\le m,n\le 1.5\times 10^5$ ）</p><ul><li><code>A x y</code>：请求出 $\sum_{i=1}^n[i\bmod x=y]\times a_i$ 的值。</li><li><code>C x y</code>：将 $a_x$ 的值修改为 $y$。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们先用最暴力的方法去处理询问。我们进行枚举，求出 $a_{0\cdot x+y}, a_{1\cdot x+y}, a_{2\cdot x+y},\cdots$ ，可以发现这是 $O(n^2)$ 的。</p><p>我们也可以暴力预处理 $f(x,y)$ 表示 $\sum_{i=1}^n[i\bmod x=y]\times a_i$ 的值，但这样时间空间复杂度都是 $O(n^2)$。</p><p>但是 $\cdots\cdots$，如果我们把这两种方式综合一下呢？</p><ul><li>对于一个询问，如果 $x&gt;\sqrt{n}$，我们就暴力枚举 $a_{0\cdot x+y}, a_{1\cdot x+y}, a_{2\cdot x+y},\cdots$，单次枚举次数不超过 $O(\sqrt{n})$。</li><li>如果 $x\le \sqrt{n}$，暴力预处理 $f(x,y)  (x,y\le\sqrt{n})$，时间复杂度 $O(n\sqrt{n})$，空间复杂度 $O(n)$。</li></ul><p>综合起来，总时间复杂度 $O(n\sqrt{n})$。这便是一种 <strong>根号算法</strong>。</p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),blk=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">    col[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=blk;++j) f[j][i%j]+=col[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> ch; <span class="keyword">int</span> a,b,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;ch; a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;blk) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i*a+b&lt;=n;++i) ans+=col[i*a+b];</span><br><span class="line">        <span class="keyword">else</span> ans=f[a][b];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=blk;++i) f[i][a%i]=f[i][a%i]-col[a]+b;</span><br><span class="line">        col[a]=b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 解题报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P7339「Kotori」解题报告</title>
      <link href="2021/05/16/luogu-p7339kotori-jie-ti-bao-gao/"/>
      <url>2021/05/16/luogu-p7339kotori-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7339">https://www.luogu.com.cn/problem/P7339</a></p><span id="more"></span><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>「世界最萌大会」开始了，Kotori 要带着 Shido 夺冠。有 $n=2^k$ 名选手，赛制为淘汰赛，每次选当前编号最小的两人为对手。Shido 的编号为 1。第 $i$ 个人必有 $p_i$ 张票。Kotori 还会在每一轮中选择一人加上 $m$ 票。如果平局，则 Kotori 可以决定比赛的胜者。请问 Shido 是否能够夺冠。$k \le 2^{18}$ 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们发现整个淘汰的过程可以用一棵 「赛事树」来体现。赛事树是一棵满二叉树。赛事树某个结点的数字表示它两个儿子之间的获胜者。根节点就是冠军。我们用 $f(i,j)$ 表示第 $i$ 个人能否在第 $j$ 回合留下。可以发现这个动态规划是 <strong>有后效性</strong> 的，所以不能写成普通的状态转移方程。</p><p>易得 $f(i,0)=1$ 。可以发现 $f(i,j-1)=1$ 是 $f(i,j)=1$ 的 <strong>必要不充分</strong> 条件。我们暂且把第 $i$ 人所在结点子树所包含的区间叫做 「主战区」，对手所在的区间叫做「对战区」，我们只需要 $i$ 能够打败当前对战区的某一个剩下来的人即可。我们可以用 $g(x)$ 表示当前回合第 $x$ 块区间胜者的 $p$ 的最小值。只要看 $p_i$ 能否打败对战区的 $g$ 值即可。最后只需判断 $f(1,k)$ 是否等于 1 即可。整个过程有点像 <strong>倍增</strong>。</p><p>整个程序的作用相当于把赛事树从下往上一层一层遍历的过程，时间复杂度 $O(nk)$。（ 即 $O(n \log n)$ ）</p><p><strong>注意</strong>：本题贪心 <strong>不是正解</strong>。</p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">k=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),n=(<span class="number">1</span>&lt;&lt;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;++j)</span><br><span class="line">        f[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    p[i]=<span class="built_in">read</span>(),f[i][<span class="number">0</span>]=<span class="number">1</span>,g[i]=p[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> blk=(<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[j][i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> now=(j<span class="number">-1</span>)/blk+<span class="number">1</span>; <span class="comment">// 所在的块</span></span><br><span class="line">        <span class="keyword">if</span>(now&amp;<span class="number">1</span>) now++;</span><br><span class="line">        <span class="keyword">else</span> now--; <span class="comment">// 与它对战的块</span></span><br><span class="line">        <span class="keyword">int</span> res=g[now];</span><br><span class="line">        <span class="keyword">if</span>(p[j]+m&gt;=res) f[j][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j) g[j]=inf;</span><br><span class="line">    blk*=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[j][i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> now=(j<span class="number">-1</span>)/blk+<span class="number">1</span>;</span><br><span class="line">        g[now]=<span class="built_in">min</span>(g[now],p[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f[<span class="number">1</span>][k]) <span class="built_in">printf</span>(<span class="string">&quot;Kotori\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Yoshino\n&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 解题报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3899「谈笑风生」解题报告</title>
      <link href="2021/05/16/luogu-p3899tan-xiao-feng-sheng-jie-ti-bao-gao/"/>
      <url>2021/05/16/luogu-p3899tan-xiao-feng-sheng-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3899">https://www.luogu.com.cn/problem/P3899</a></p><span id="more"></span><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>$T$ 为一棵有 $n$ 个结点且根结点是 1 的有根树。有 $q$ 个询问，每个询问包含 $p$ 和 $k$ ，请求出有多少个三元组 $(a,b,c)$ 满足 $a \not= b \not= c$ ，且 $a,b$ 均为 $c$ 的祖先，$a$ 与 $b$ 的距离不超过 $k$ , $a$ 为结点 $p$ 。询问离线。$1 \le n,q \le 3 \times 10^5$ 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考虑 <strong>树上启发式合并</strong> 。</p><p><strong>性质</strong> / $a$ , $b$ , $c$ 必然在一条链上。证明显然。所以我们分两种情况讨论：</p><ol><li><p>$b$ 为 $a$ 的祖先</p><p>此时对答案的贡献为 $\min(dep(a)-dep(1),k)\times(siz(a)-1)$ 。</p><p>这可以理解为：$c$ 可以是 $a$ 子树中任意一个元素，$b$ 则至多为 $a$ 的 $k$ 级祖先。由乘法原理可以算出答案。</p></li><li><p>$b$ 在 $a$ 的子树中</p><p>我们考虑假设有一个能够成为 $b$ 的点 $y$ , 它对答案的贡献为 $siz(y)-1$ 。而成为 $b$ 的点，它的深度减去 $a$ 的深度一定不超过 $k$ 。我们设 $num(x)=\sum_{dep(i)=x}(siz(x)-1)$ 。那么，最终对答案的贡献为</p><script type="math/tex; mode=display">\sum_{i=dep(a)+1}^{\min(n,dep(a)+k)}num(i)</script><p>这个式子可以使用 <strong>树状数组</strong> 在 $O(\log n)$ 的时间复杂度内解决。</p></li></ol><p>所以，总时间复杂度为 $O(n\log^2n)\times O(\log n)=O(n \log^3n)$ 。由于树状数组和启发式合并的常数很小，实际上是可以过去的。此外，本题还有一种叫做 <strong>线段树合并</strong> 的解法。</p><p><strong>注意</strong>：此题的输入边时的 $u$ <strong>并不是父亲</strong>，$v$ <strong>也并不是儿子</strong>。</p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[x]=f,dep[x]=dep[f]+<span class="number">1</span>,siz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Head[x];i;i=Edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=Edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x),siz[x]+=siz[y];</span><br><span class="line">        son[x]=(siz[y]&gt;siz[son[x]])?y:son[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> flag,<span class="keyword">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Update</span>(dep[x],opt*(siz[x]<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Head[x];i;i=Edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=Edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y!=flag &amp;&amp; y!=fa[x]) <span class="built_in">Solve</span>(y,flag,opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Head[x];i;i=Edge[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=Edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==son[x] || y==fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) <span class="built_in">dfs</span>(son[x],<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Solve</span>(x,son[x],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:v[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k=y.first,id=y.second,res=<span class="number">0</span>;</span><br><span class="line">        res=res+<span class="built_in">min</span>(k,dep[x]<span class="number">-1</span>)*(siz[x]<span class="number">-1</span>);</span><br><span class="line">        res=res+<span class="built_in">Count</span>(<span class="built_in">min</span>(n,dep[x]+k))-<span class="built_in">Count</span>(dep[x]);</span><br><span class="line">        ans[id]=res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!opt) <span class="built_in">Solve</span>(x,<span class="number">0</span>,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n=<span class="built_in">read</span>(),q=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">Addedge</span>(a,b),<span class="built_in">Addedge</span>(b,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">    v[p].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(k,i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>),<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 解题报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces 9D「How many trees?」解题报告</title>
      <link href="2021/05/16/cf9dhow-many-trees-jie-ti-bao-gao/"/>
      <url>2021/05/16/cf9dhow-many-trees-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF9D">https://www.luogu.com.cn/problem/CF9D</a></p><span id="more"></span><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>用 $n$ 个点组成的二叉树，问高度 $\ge h$ 的有多少个。$1 \le h \le n \le 35$ 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考虑动态规划（ 记忆化搜索 ）。设 $f(x,y)$ 表示有 $x$ 个结点，高度 $\ge y$ 的二叉树的个数。</p><p>边界条件：$x=0$ 时 $f(x,y)=1$ ，$x&lt;y$ 时 $f(x,y)=0$ 。</p><p>考虑枚举二叉树上两子树的大小（ 分别为 $a ,  b$ ，且满足 $a+b=n$ ）</p><ul><li><p>$a\ge y-1  \text{and} b&lt;y-1$ 时，$f(x,y)=f(x,y)+f(a,y-1)\cdot f(b,0)$ 。</p></li><li><p>$a&lt; y-1  \text{and} b \ge y-1$ 时，$f(x,y)=f(x,y)+f(a,0)\cdot f(b,y-1)$ 。</p></li><li><p>$a,b\ge y-1$ 时，需要用到 <strong>容斥原理</strong> ，</p><script type="math/tex; mode=display">f(x,y)=f(x,y)+f(a,y-1)\cdot f(b,0)+f(a,0)\cdot f(b,y-1)-f(a,y-1)\cdot f(b,y-1)</script></li></ul><p>最后输出 $f(n,h)$ 的值即可。</p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[x][y]) <span class="keyword">return</span> f[x][y];</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=i,b=x-i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=y<span class="number">-1</span> &amp;&amp; b&lt;y<span class="number">-1</span>) f[x][y]+=<span class="built_in">dfs</span>(a,y<span class="number">-1</span>)*<span class="built_in">dfs</span>(b,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(a&lt;y<span class="number">-1</span> &amp;&amp; b&gt;=y<span class="number">-1</span>) f[x][y]+=<span class="built_in">dfs</span>(a,<span class="number">0</span>)*<span class="built_in">dfs</span>(b,y<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a&gt;=y<span class="number">-1</span> &amp;&amp; b&gt;=y<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            f[x][y]=f[x][y]+<span class="built_in">dfs</span>(a,y<span class="number">-1</span>)*<span class="built_in">dfs</span>(b,<span class="number">0</span>)+<span class="built_in">dfs</span>(a,<span class="number">0</span>)*<span class="built_in">dfs</span>(b,y<span class="number">-1</span>)-<span class="built_in">dfs</span>(a,y<span class="number">-1</span>)*<span class="built_in">dfs</span>(b,y<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">// important!</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[x][y]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> f[x][y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 解题报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P2848「Cow Checklist G」解题报告</title>
      <link href="2021/05/16/luogu-p2848cow-checklist-g-jie-ti-bao-gao/"/>
      <url>2021/05/16/luogu-p2848cow-checklist-g-jie-ti-bao-gao/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2848">https://www.luogu.com.cn/problem/P2848</a></p><span id="more"></span><h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>$n$ 个 $H$ 牛编号 $1\sim n$, $m$ 个 $G$ 牛编号 $1\sim m$，你需要以出发点为 $H_1$ ,结束点为 $H_n$，遍历每一头牛。两种牛可以交替访问，但是同种牛的访问顺序必须是从小到大。每个牛有平面坐标，两头牛的距离为它们欧氏距离的平方。你需要在保证距离最短的情况下完成遍历。 $n,m\le 10^3$ 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们设 $f(i,j,0/1)$ 表示第 $i$ 头遍历的牛到底是 $H_j$ (1) 还是 $G_j$ (0)。由题得</p><script type="math/tex; mode=display">f(i,j,0)=\min(f(i-1,j-1,0)+dis(j-1,j),f(i-1,i-j,1)+dis(i-j,j))\\f(i,j,1)=\min(f(i-1,j-1,1)+dis(j-1,j),f(i-1,i-j,0)+dis(i-j,j))</script><p>注意一些限制条件，时间复杂度 $O(n^2)$ 。</p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> (X[a]-X[b])*(X[a]-X[b])+(Y[a]-Y[b])*(Y[a]-Y[b]);&#125;</span><br><span class="line"></span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>,f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n+m;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">min</span>(<span class="built_in">max</span>(n,m),i);++j)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][j][<span class="number">0</span>]=f[i][j][<span class="number">1</span>]=inf;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;=n &amp;&amp; i-j&lt;=m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=i-j;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;<span class="number">1</span>) f[i][j][<span class="number">0</span>]=<span class="built_in">min</span>(f[i][j][<span class="number">0</span>],f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]+<span class="built_in">dis</span>(j<span class="number">-1</span>,j));</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=<span class="number">1</span>) f[i][j][<span class="number">0</span>]=<span class="built_in">min</span>(f[i][j][<span class="number">0</span>],f[i<span class="number">-1</span>][k][<span class="number">1</span>]+<span class="built_in">dis</span>(n+k,j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;=m &amp;&amp; i-j&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k=i-j;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;<span class="number">1</span>) f[i][j][<span class="number">1</span>]=<span class="built_in">min</span>(f[i][j][<span class="number">1</span>],f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>]+<span class="built_in">dis</span>(n+j<span class="number">-1</span>,n+j));</span><br><span class="line">            <span class="keyword">if</span>(k&gt;=<span class="number">1</span>) f[i][j][<span class="number">1</span>]=<span class="built_in">min</span>(f[i][j][<span class="number">1</span>],f[i<span class="number">-1</span>][k][<span class="number">0</span>]+<span class="built_in">dis</span>(k,n+j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,f[n+m][n][<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 解题报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈点分治</title>
      <link href="2021/05/16/qian-tan-dian-fen-zhi/"/>
      <url>2021/05/16/qian-tan-dian-fen-zhi/</url>
      
        <content type="html"><![CDATA[<p>点分治是一种高效处理树上任意 / 特定两点距离的算法，它的精髓在于每次分治查找重心使得分治的层数在 $O(\log n)$ 级别，使得时间复杂度为 $O(n\log n)$。点分治是 <strong>离线且不可修改</strong> 的，需要修改就得用一种叫做点分树的东西，它的本质也是重心优化。</p><span id="more"></span><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Let’s look at a <a href="https://www.luogu.com.cn/problem/P3806">模板题</a> first.</p><p>我们来看看最基础的办法：</p><hr><p>暴力枚举两个点，计算他们的 <code>LCA</code> 之后算出距离。</p><p>时间复杂度：</p><p>首先一遍 <code>dfs</code> : $O(n)$</p><p>求两个点的 <code>LCA</code> 一共 $n^2$ 次：$O((n+n^2)\log_2n)$</p><p>对每两个点判断答案： $O(n^2m)$</p><p>明显超时。</p><hr><p>我们还可以想出一个经过一些优化的方法：</p><p>对每个点进行一遍 <code>dfs</code> ，在 <code>dfs</code> 过程中计算距离。</p><p>时间复杂度：</p><p>一遍 <code>dfs</code> （附加处理询问）：$O(nm)$ </p><p>由于总共需要进行 $n$ 次 <code>dfs</code> , 总时间复杂度为 $O(n^2m)$ 。</p><p>也会超时。</p><hr><p>所以，我们就要引入一个方法：</p><h3 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h3><p>点分治是利用 <strong>分治</strong> 的方法来判断这些的。</p><p>我们先来看看一棵树：</p><p><img src="https://s1.ax1x.com/2020/04/05/GB04c6.png" alt="GB04c6.png"></p><p>我们来想想，路径这个东西该怎么拆分：</p><p>两点之间的一条路径，<strong>一定是由一棵子树上根结点到两点的距离拼接而成的</strong> 。</p><p>比如结点 2 到结点 6 的路径，就是这样来的：</p><p><img src="https://s1.ax1x.com/2020/04/05/GBDiqO.png" alt="GBDiqO.png"></p><p>它就是由红色路径和蓝色路径拼接而成的。</p><p>点分治的思想就运用了这个特点。</p><hr><p>假设我们运用这个方法，处理好了根结点到其他结点的距离，也处理好经过根结点的路径之后，可以做什么了呢？</p><p><strong>删掉根结点！</strong></p><p><del>（欢呼雀跃）</del></p><p>接下来这棵树就变成了这样子：</p><p><img src="https://s1.ax1x.com/2020/04/05/GBD4eO.png" alt="GBD4eO.png"></p><p>我们只要再以 1 的儿子（ 即 2 , 3 ） 为根结点，递归处理询问就可以了！</p><p><del>（这就是点分治的全部流程了）</del></p><p>（你看，多么 <del>简单</del>  毒瘤）</p><hr><p>不过，处理的时候，我们可能还要这样：</p><p>万一处理的树是一条链呢？（ like this ）</p><p><img src="https://s1.ax1x.com/2020/04/05/GBrDjP.png" alt="GBrDjP.png"></p><p>它的递归深度可以达到 <del>惊人的</del> $n$ 层！</p><p>所以，我们为了避免这个问题，我们还需要增加一个操作：</p><p><strong>找重心</strong> 。</p><p>我们先 <del>熟练地</del> 打开 <a href="https://www.baidu.com/">百度</a> ，搜索 <code>树的重心</code> ，它会给你这样一个结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">树的重心也叫树的质心。</span><br><span class="line">找到一个点,其所有的子树中最大的子树节点数最少,</span><br><span class="line">那么这个点就是这棵树的重心,</span><br><span class="line">删去重心后，生成的多棵树尽可能平衡。</span><br></pre></td></tr></table></figure><p>我们找到树的重心之后，将重心设为新的根，树就可以变成这样了：</p><p><img src="https://s1.ax1x.com/2020/04/05/GBsyx1.png" alt="GBsyx1.png"></p><p>这棵树果然平衡了许多！</p><p>就是因为这样，点分治的时间复杂度可以达到 $O(n\log_2n)$ 了！</p><hr><h3 id="代码环节"><a href="#代码环节" class="headerlink" title="代码环节"></a>代码环节</h3><p>前期必备：（邻接表）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxn int(1e4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxq 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxk int(1e7)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,nxt,w;</span><br><span class="line">&#125; Edge[(Maxn&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> tot,Head[Maxn+<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Edge[++tot].to=v;</span><br><span class="line">Edge[tot].nxt=Head[u];</span><br><span class="line">Edge[tot].w=w;</span><br><span class="line">Head[u]=tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们要找重心。</p><p>找重心需要的变量有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root : 当前的重心 &amp; 根</span><br><span class="line">siz[] : 子树大小</span><br><span class="line">maxs[] : 一个结点最大儿子的子树大小（这里包括父亲结点）</span><br><span class="line">sum : 因为有些结点会被删除，所以它记录未被删除的点个数</span><br><span class="line">vis[] : 标记被删除的点</span><br></pre></td></tr></table></figure><p>我们只需要用到 <code>重心的所有子树中最大的子树节点数最少</code> 这一特性就可以找到重心了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n,q,root;</span><br><span class="line"><span class="keyword">int</span> siz[Maxn+<span class="number">5</span>],maxs[Maxn+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> vis[Maxn+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span><span class="comment">//找重心 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">siz[x]=<span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">maxs[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=Head[x];i;i=Edge[i].nxt)</span><br><span class="line">&#123;<span class="comment">//遍历每个儿子</span></span><br><span class="line"><span class="keyword">int</span> v=Edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(vis[v] || v==f) <span class="keyword">continue</span>;<span class="comment">//如果儿子被删去或者它为父结点，则跳过它</span></span><br><span class="line"><span class="built_in">getroot</span>(v,x);<span class="comment">//递归处理</span></span><br><span class="line">siz[x]+=siz[v];</span><br><span class="line">maxs[x]=<span class="built_in">max</span>(maxs[x],siz[v]);<span class="comment">//比较各个儿子的大小</span></span><br><span class="line">&#125;</span><br><span class="line">maxs[x]=<span class="built_in">max</span>(maxs[x],sum-siz[x]);<span class="comment">//跟它的父亲结点大小比较</span></span><br><span class="line">root=maxs[x]&lt;maxs[root]?x:root;<span class="comment">//更新重心</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于当前的 <code>siz[]</code> 是以原来的根（初始为结点 1 ）的子树大小，但现在的根已经更新了，所以我们要<strong>找到重心后再次以重心为根调用该函数</strong>。</p><hr><p>接下来，我们需要处理根结点到各个结点的距离。</p><p>变量如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dis[] : 统计各个结点到根结点的距离</span><br><span class="line">now[] : 存放这些距离</span><br><span class="line">nowdis: 计数器，与 now[] 配合使用</span><br></pre></td></tr></table></figure><p>代码如下：（这个应该很简单吧）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dis[Maxn+<span class="number">5</span>],now[Maxn+<span class="number">5</span>],nowdis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">now[++nowdis]=dis[x];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=Head[x];i;i=Edge[i].nxt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v=Edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(vis[v] || v==f) <span class="keyword">continue</span>;</span><br><span class="line">dis[v]=dis[x]+Edge[i].w;</span><br><span class="line"><span class="built_in">getdis</span>(v,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>接下来，我们就要开始写分治函数了：</p><p>回顾一下步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 删除根结点，并统计以它为根的距离，处理询问</span><br><span class="line">2. 遍历每个以它的儿子为根的子树，找到它的重心，以新的重心为根继续分治</span><br><span class="line">3. 终止条件：所有结点均已被删除</span><br></pre></td></tr></table></figure><p>变量列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query[] : 存储每个询问</span><br><span class="line">ans[] : 存储每个询问的答案</span><br><span class="line">alive[] : 表示在之前子树上这个距离是否存在</span><br><span class="line">stack&lt;int&gt; s : 使用一个栈统一进行加入和清空操作</span><br></pre></td></tr></table></figure><p>样例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> query[Maxq+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> ans[Maxq+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> alive[Maxk+<span class="number">5</span>];</span><br><span class="line">stack&lt;<span class="keyword">int</span>&gt; s;<span class="comment">//使用栈统一处理 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//计算距离 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=Head[x];i;i=Edge[i].nxt)</span><br><span class="line">&#123;<span class="comment">//遍历儿子结点 </span></span><br><span class="line"><span class="keyword">int</span> v=Edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">nowdis=<span class="number">0</span>;</span><br><span class="line">dis[v]=Edge[i].w;</span><br><span class="line"><span class="built_in">getdis</span>(v,x);<span class="comment">//更新距离 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=nowdis;++j)<span class="comment">//扫每个距离 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=q;++k)<span class="comment">//扫每个询问 </span></span><br><span class="line"><span class="keyword">if</span>(query[k]&gt;=now[j])<span class="comment">//如果路径可以由这两段拼出来，那么它就存在 </span></span><br><span class="line">ans[k]|=alive[query[k]-now[j]];</span><br><span class="line">                    <span class="comment">//&#x27;|&#x27;这个运算,只要两边一个为 1 ,它的值就为 1 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=nowdis;++j)<span class="comment">//存放距离 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(now[j]&gt;Maxk) <span class="keyword">continue</span>;<span class="comment">//如果它大于询问的最大值，跳过 </span></span><br><span class="line">s.<span class="built_in">push</span>(now[j]);<span class="comment">//统一加入栈 </span></span><br><span class="line">alive[now[j]]=<span class="literal">true</span>;<span class="comment">//由于现在它已经成为了“之前的子树”，所以把它标记 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!s.<span class="built_in">empty</span>())<span class="comment">//清空所有现在的标记 </span></span><br><span class="line">&#123;</span><br><span class="line">alive[s.<span class="built_in">top</span>()]=<span class="literal">false</span>;</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">devide</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//点分治</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vis[x]=<span class="literal">true</span>;<span class="comment">//删点 </span></span><br><span class="line">alive[<span class="number">0</span>]=<span class="literal">true</span>;<span class="comment">//距离它为 0 的结点就是它自己，肯定存在 </span></span><br><span class="line"><span class="built_in">count</span>(x);<span class="comment">//统计 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=Head[x];i;i=Edge[i].nxt)</span><br><span class="line">&#123;<span class="comment">//遍历每个儿子 </span></span><br><span class="line"><span class="keyword">int</span> v=Edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">root=<span class="number">0</span>;<span class="comment">//初始化重心 </span></span><br><span class="line">maxs[<span class="number">0</span>]=sum=siz[v];</span><br><span class="line"><span class="built_in">getroot</span>(v,<span class="number">0</span>);<span class="comment">//找到重心并且更新子树大小 </span></span><br><span class="line"><span class="built_in">getroot</span>(root,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">devide</span>(root);<span class="comment">//继续分治 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>接下来就是主函数部分了：（这应该也很简单吧）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)<span class="comment">//连边 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line"><span class="built_in">Addedge</span>(a,b,c);</span><br><span class="line"><span class="built_in">Addedge</span>(b,a,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i)<span class="comment">//读入询问 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;query[i]);</span><br><span class="line"></span><br><span class="line">maxs[<span class="number">0</span>]=sum=n;</span><br><span class="line"><span class="built_in">getroot</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">getroot</span>(root,<span class="number">0</span>);<span class="comment">//找重心并更新子树大小 </span></span><br><span class="line"><span class="built_in">devide</span>(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ans[i]?<span class="string">&quot;AYE&quot;</span>:<span class="string">&quot;NAY&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p><code>alive</code> 这个数组一定要是 <code>bool</code> 类型，不然 $10^7$ 会导致你超空间的！</p></li><li><p><code>alive</code> 这个数组也不要轻易 <code>memset</code> ，因为这个操作的时间复杂度是线性的，很可能会超时。你只需要用一个栈来记录该标记的和该清空的，统一处理就行了。</p></li><li><p>建议一次点分治处理全部的询问，时间复杂度仅为 $O(nm\log_2n)$ 。如果一次处理一个询问，代码复杂度更高不说，程序还会浪费掉非常多的时间。</p></li></ol><hr><p>常见问题：</p><p><strong>Q:</strong> 为什么 <code>TLE</code> , <code>MLE</code> 一大堆？</p><p><strong>A:</strong> 应该是邻接表空间需要开两倍的问题。</p><p><strong>Q:</strong> 为什么程序编译报错了？</p><p><strong>A:</strong> 不用万能头试一下。</p><p><strong>Q:</strong> 为什么一直输出 <code>NAY</code> ?</p><p><strong>A:</strong> 应该是邻接表还需要记录边权的问题。</p><p><strong>Q:</strong> 为什么测试点 7 一直 <code>RE</code> ？</p><p><strong>A:</strong> 看<a href="https://www.luogu.com.cn/discuss/show/188596">这个帖子</a>。</p><hr><p>完整代码：</p><p>（防抄袭，改了些不重要的地方）</p><p><a href="https://www.luogu.com.cn/paste/6jypr7uu">there</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 树论 / 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python！</title>
      <link href="2021/05/16/python/"/>
      <url>2021/05/16/python/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇博客是专门为课本上的内容而编写的。</p><p>Python 是所有编程语言中语法 <strong>相对十分简单</strong> 的，比较适合初学者学习。由于教材上面的课程安排比较迷惑，这篇博客就起到了补充作用。</p><p>这篇教程里面的知识点分为两类：教材上的基础知识点和拓展知识点。同样，练习也分为两种，较为简单的练习和一些拓展练习。标注星号 “*” 的内容是选读内容。</p><span id="more"></span><hr><h2 id="0-不得不说的内容"><a href="#0-不得不说的内容" class="headerlink" title="0. 不得不说的内容"></a>0. 不得不说的内容</h2><ul><li><strong>注释</strong></li></ul><p>在 Python 中，存在类似于数学草稿的东西，用于更好的理解程序，这个东西叫做 <strong>注释</strong>。</p><p>注释的几种形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只有一行的注释</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">也是多行注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>注释对于整个程序的运行没有任何作用，你甚至把它们删掉都不影响运行。</p><hr><ul><li><strong>程序的交互</strong></li></ul><p>一般来说，程序的交互分为两个部分，<strong>输入</strong> ( Input ) 和 <strong>输出</strong> ( Output ) 。</p><p>输入，就是用键盘将文字写入到运行区域的过程。</p><p>输出，是程序把一些文字显示到运行区域的过程。</p><p>输入输出可以 <strong>交替进行</strong> 。</p><hr><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><ul><li><strong>变量是什么</strong></li></ul><p>不同于数学里面的变量，在 Python 中，<strong>变量</strong> 是可变的量。每个变量就像一个盒子，存储着一些数据。这些数据可能是数字，字符串，或是其它的一些东西。你可以随意改变和读取盒子里面的东西。</p><hr><ul><li><strong>变量的类型</strong></li></ul><p>Python 中，常用的变量类型有四种：</p><div class="table-container"><table><thead><tr><th style="text-align:center">变量类型</th><th style="text-align:center">存储内容</th></tr></thead><tbody><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center">整数</td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center">浮点数（ 小数或整数加上 “.0” 就是浮点数 ）</td></tr><tr><td style="text-align:center"><code>str</code></td><td style="text-align:center">字符串</td></tr><tr><td style="text-align:center"><code>bool</code>*</td><td style="text-align:center">二进制值 True (1) 和 False (0)</td></tr></tbody></table></div><p><strong>注意</strong>：<code>float</code> 类型的浮点数一定要带上 <strong>小数点</strong> ，<code>str</code> 类型的字符串前后一定要加上 <strong>单引号或者双引号</strong> 。</p><hr><ul><li><strong>如何定义变量</strong></li></ul><p>变量都有一个名称，叫做 <strong>变量名</strong>。变量名只能由字母，数字和下划线组成，而且 <strong>数字不能放在变量名开头</strong>。</p><p><strong>「 Example 1 」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a    <span class="comment"># 正确</span></span><br><span class="line">abc  <span class="comment"># 正确</span></span><br><span class="line">a1   <span class="comment"># 正确</span></span><br><span class="line">_a   <span class="comment"># 正确</span></span><br><span class="line">1a   <span class="comment"># 错误</span></span><br><span class="line">a?   <span class="comment"># 错误</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：对于不同的变量，变量名 <strong>不能重复</strong>。</p><p>定义变量的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 = 内容</span><br></pre></td></tr></table></figure><p>在 Python 中，等号是 <strong>赋值</strong> 的意思。如果出现了 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=b</span><br></pre></td></tr></table></figure><p>这种语句，则表示将变量 $b$ 的值给了变量 $a$ 。</p><p><strong>注意</strong>：这个变量的类型由 <strong>等号后面的内容</strong> 所决定。</p><p><strong>「 Example 2 」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">3</span>      <span class="comment"># int</span></span><br><span class="line">a=-<span class="number">100</span>   <span class="comment"># int</span></span><br><span class="line">c=<span class="number">3.0</span>    <span class="comment"># float</span></span><br><span class="line">d=<span class="number">3.14</span>   <span class="comment"># float</span></span><br><span class="line">e=<span class="string">&quot;1&quot;</span>    <span class="comment"># str</span></span><br><span class="line">f=<span class="string">&#x27;abc&#x27;</span>  <span class="comment"># str</span></span><br><span class="line">g=???    <span class="comment"># 错误</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>强制转换</strong></li></ul><p>一个变量是可以通过一种类型转换到另一种类型的。</p><p><strong>「 Example 3 」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">3</span>         <span class="comment"># 此时 a 为 int 类型</span></span><br><span class="line">b=<span class="built_in">float</span>(a)  <span class="comment"># 此时 b 为 float 类型</span></span><br><span class="line">c=<span class="built_in">int</span>(b)    <span class="comment">#     c 为 int 类型</span></span><br><span class="line">d=<span class="built_in">str</span>(c)    <span class="comment">#     d 为 str 类型</span></span><br><span class="line">e=<span class="built_in">float</span>(d)  <span class="comment">#     e 为 float 类型</span></span><br><span class="line">f=<span class="built_in">int</span>(c)    <span class="comment">#     f 为 int 类型</span></span><br><span class="line">g=<span class="built_in">str</span>(e)    <span class="comment">#     g 为 str 类型</span></span><br></pre></td></tr></table></figure><p>但是，强制转换是有原则的：（*）</p><div class="table-container"><table><thead><tr><th style="text-align:center">转换后 / 转换前</th><th style="text-align:center">int</th><th style="text-align:center">float</th><th style="text-align:center">str</th></tr></thead><tbody><tr><td style="text-align:center"><strong>int</strong></td><td style="text-align:center">类型一致，<strong>无需转换</strong></td><td style="text-align:center">向 <strong>零</strong> 取整</td><td style="text-align:center">去掉两侧引号</td></tr><tr><td style="text-align:center"><strong>float</strong></td><td style="text-align:center">在后面加上 <code>.0</code></td><td style="text-align:center">类型一致，<strong>无需转换</strong></td><td style="text-align:center">去掉两侧引号</td></tr><tr><td style="text-align:center"><strong>str</strong></td><td style="text-align:center">两侧加上引号</td><td style="text-align:center">两侧加上引号</td><td style="text-align:center">类型一致，<strong>无需转换</strong></td></tr></tbody></table></div><p><strong>「 Example 4 」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下代码可以自己复制并编辑器内运行</span></span><br><span class="line"><span class="comment"># 输出应为: 5.0 5 3.6 3 -3</span></span><br><span class="line"></span><br><span class="line">a1=<span class="number">5</span></span><br><span class="line">a2=<span class="built_in">float</span>(a1)  <span class="comment"># a2=5.0</span></span><br><span class="line">a3=<span class="built_in">str</span>(a1)    <span class="comment"># a3=&quot;5&quot;</span></span><br><span class="line"></span><br><span class="line">b1=<span class="number">3.6</span></span><br><span class="line">b2=<span class="built_in">str</span>(b1)    <span class="comment"># b2=&quot;3.6&quot;</span></span><br><span class="line">b3=<span class="built_in">int</span>(b1)    <span class="comment"># b3=3</span></span><br><span class="line"></span><br><span class="line">c1=<span class="string">&quot;-3&quot;</span></span><br><span class="line">c2=<span class="built_in">int</span>(c1)    <span class="comment"># c2=-3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a2,a3,b2,b3,c2)  <span class="comment"># Python 自带的输出操作</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-运算-amp-输入输出"><a href="#2-运算-amp-输入输出" class="headerlink" title="2. 运算 &amp; 输入输出"></a>2. 运算 &amp; 输入输出</h2><p>在 Python 中，许多运算和数学上的运算十分相似。</p><ul><li><strong>四则运算</strong></li></ul><p>首先是加减法，跟数学的运算法则相同。</p><p>乘法也是差不多的，只是把数学中的乘号换成了星号 <code>*</code> 。</p><p>除法则分为两种，<strong>整数除法</strong> <code>//</code> ，结果是 int 类型，还有一种是 <strong>小数除法</strong> <code>/</code> ，结果是 float 类型。</p><p><strong>注意</strong>：整数除法如果除不尽会 <strong>向下取整</strong>。</p><p><strong>「 Example 1 」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">3</span></span><br><span class="line">b=<span class="number">5</span></span><br><span class="line">c=a+b      <span class="comment"># c 的值为 8</span></span><br><span class="line">d=a-b      <span class="comment"># d 的值为 -2</span></span><br><span class="line"></span><br><span class="line">a1=<span class="number">3</span></span><br><span class="line">b1=<span class="number">5</span></span><br><span class="line">c1=a1*b1   <span class="comment"># c1 的值为 15</span></span><br><span class="line"></span><br><span class="line">a2=<span class="number">8</span></span><br><span class="line">b2=-<span class="number">8</span></span><br><span class="line">c2=<span class="number">3</span></span><br><span class="line">d2=a2//b2  <span class="comment"># d2 的值为 -1</span></span><br><span class="line">e2=a2//c2  <span class="comment"># e2 的值为 2</span></span><br><span class="line">f2=b2/c2   <span class="comment"># f2 的值为 -2.666...</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>模运算和乘方运算</strong></li></ul><p>取余运算又叫 <strong>模运算</strong>。$a$ 除以 $b$ 得到的余数值也可以说成 $a$ <strong>模</strong> $b$ 的值。模运算用百分号 <code>%</code> 表示。乘方运算则是两个乘号 <code>**</code> ，运算符两边的东西可以是 int 类型，也可以是 float 类型。</p><p><strong>「 Example 2 」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">4</span></span><br><span class="line">b=<span class="number">3</span></span><br><span class="line">c=a**b   <span class="comment"># c 的值为 64</span></span><br><span class="line">d=a**<span class="number">0.5</span> <span class="comment"># d 的值为 2</span></span><br><span class="line">e=<span class="number">8</span>%b    <span class="comment"># e 的值为 2</span></span><br><span class="line">f=a%b    <span class="comment"># f 的值为 1</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>输入和输出语句</strong></li></ul><p>这个语句用于输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>()</span><br></pre></td></tr></table></figure><p>输入的内容被系统默认是 <strong>字符串</strong>，也就是 str 类型。如果你想要输入一个数字，请输入后进行 <strong>强制转换</strong>。括号中也可以填写一些东西，表示输入之前屏幕上会显示些什么。</p><p><strong>注意</strong>：这个语句会直接读入 <strong>一行</strong> 的内容。如果你在一行中输入了两个数字，中间带一个空格，使用输入语句然后转换到 int 类型的话，是会 <strong>转换失败</strong> 的。（ 因为那个空格也被当作了待转换的内容 ）</p><p><strong>「 Example 3 」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="built_in">input</span>(<span class="string">&quot;Hello,world!&quot;</span>) <span class="comment"># a 为 str 类型</span></span><br><span class="line">b=<span class="built_in">int</span>(<span class="built_in">input</span>())          <span class="comment"># b 为 int 类型</span></span><br><span class="line">c=<span class="built_in">float</span>(<span class="built_in">input</span>(<span class="number">1903</span>))    <span class="comment"># c 为 float 类型</span></span><br></pre></td></tr></table></figure><p>这个语句用于输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><p>你可以将变量，数字，字符串等直接放到括号里面输出。</p><p><strong>「 Program 1 」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">b=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">233</span>)</span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">abc</span><br><span class="line">233</span><br></pre></td></tr></table></figure><p>如果你需要输出多个内容（ 类型可以不同 ），就需要在语句的括号内用 <strong>逗号</strong> 隔开它们。这些内容输出时，中间会显示一个空格。</p><p><strong>「 Program 2 」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">5</span></span><br><span class="line">b=<span class="number">3.14</span></span><br><span class="line">c=<span class="string">&quot;orz&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;wow&quot;</span>,<span class="number">233</span>,c)</span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 3.14</span><br><span class="line">wow 233 orz</span><br></pre></td></tr></table></figure><p>我们可以发现，每次执行完 <code>print()</code> 操作之后都会再输出一个字符。这个字符一般是 <strong>空行</strong>。在输出后面加上一些东西就可以来更改最后再输出的一个字符。(*)</p><p><strong>「 Program 3 」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">5</span></span><br><span class="line">b=<span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 abc</span><br></pre></td></tr></table></figure><p>当然，这样也是可以的：</p><p><strong>「 Program 4 」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;b=<span class="number">2</span>;c=<span class="number">3</span>;d=<span class="number">4</span>;e=<span class="number">5</span>;f=<span class="number">6</span>;   <span class="comment"># 通过分号将多个语句合并在一行</span></span><br><span class="line"><span class="built_in">print</span>(a,b,c,end=<span class="string">&quot;k abc!\n&quot;</span>) <span class="comment"># 空行的字符为 &#x27;\n&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"><span class="built_in">print</span>(f)</span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3k abc!</span><br><span class="line">4 5</span><br><span class="line">6</span><br></pre></td></tr></table></figure><hr><h2 id="4-循环语句"><a href="#4-循环语句" class="headerlink" title="4. 循环语句"></a>4. 循环语句</h2><p><strong>「 Example 1 」</strong></p><p>有一天，轩轩要求你要用 Python 输出 1-5 的所有整数。于是你立刻写出了这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>接下来，他又要求你输出 1-20 的所有整数。你并不像轩轩那样勤奋，于是你开始寻找一个更加优秀的方法。那个方法就是 <strong>循环</strong> 。</p><hr><ul><li><strong>感知循环</strong></li></ul><p>有时，我们需要做一件事很多遍，为了不写过多重复的代码，我们需要循环。在教材中，循环语句是 <strong>for</strong> 语句。其实，还有一种称作 while 语句的循环，你可以自行查阅探索。</p><p>for 语句的结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 循环节 :</span><br><span class="line">    循环体</span><br></pre></td></tr></table></figure><p>跟 if 语句一样，后面的逗号和循环体的缩进一定不能忘记。</p><p>输出 1-20 的所有整数，用 for 语句可以这样实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>其中，循环的变量是 i ，循环节是那一大块的括号，循环体则是 print 语句。</p><p>而且，循环节还可以是字符串。For example，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">&quot;ab12c3&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>其中 i 表示的是字符串 s 中的每一个字符。</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">c</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>同样的，你也可以这样做：</p><hr><p><strong>「 Program 1 」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(i,i*i,i*i+<span class="number">2</span>*i+<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;nice job!&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 1 4</span><br><span class="line">nice job!</span><br><span class="line">2 4 9</span><br><span class="line">nice job!</span><br><span class="line">3 9 16</span><br><span class="line">nice job!</span><br><span class="line">4 16 25</span><br><span class="line">nice job!</span><br><span class="line">5 25 36</span><br><span class="line">nice job!</span><br><span class="line">6 36 49</span><br><span class="line">nice job!</span><br></pre></td></tr></table></figure><hr><p><strong>「 Program 2 」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">now=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    now=now+i</span><br><span class="line">    <span class="built_in">print</span>(now)</span><br><span class="line"><span class="built_in">print</span>(now*now)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">9</span><br><span class="line">7</span><br><span class="line">16</span><br><span class="line">9</span><br><span class="line">25</span><br><span class="line">11</span><br><span class="line">36</span><br><span class="line">1296</span><br></pre></td></tr></table></figure><hr><p><strong>「 Example 2 」</strong></p><p>轩轩继续要求你输出 1-100 的整数。</p><p>你依旧不像他那样勤劳，不想写那么长的循环节，于是你于是你开始寻找一个更加优秀的方法。那个方法就是 <strong>range 语句</strong> 。</p><p>range 语句是 for 循环的好帮手，主要充当循环节的作用。</p><hr><ul><li><strong>灵活使用 range</strong></li></ul><p>for 循环使用 range 语句后，结构会变成这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> <span class="built_in">range</span>(起始,终值,步长):</span><br><span class="line">    循环体</span><br></pre></td></tr></table></figure><p>range 语句中，起始指的是循环开始的数字，终值表示循环到哪个数字会结束，而步长是指循环一次会跳过多少个数字。<strong>注意：循环在起始处开始运行，将要到终值时结束，不会循环到终值这个数字。</strong></p><p>如果上面那句话你还不懂，请看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>指的是 1-<strong>99</strong> 之间的数字，而</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>才是指 1-100 之间的数字。</p><p>同样的：</p><hr><p><strong>「 Example 3 」</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>,<span class="number">2</span>)  <span class="comment"># 1-100 之间的奇数</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>,<span class="number">101</span>,<span class="number">2</span>)  <span class="comment"># 1-100 之间的偶数</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">100</span>,<span class="number">0</span>,-<span class="number">1</span>) <span class="comment"># 1-100 的倒序</span></span><br><span class="line"><span class="built_in">range</span>(a,b+<span class="number">1</span>,<span class="number">1</span>)  <span class="comment"># a-b 之间的数字</span></span><br></pre></td></tr></table></figure><p>于是，期末考试第三题便可以这样完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>或者是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><hr><p><strong>「 Problem 1 」<a href="https://www.luogu.com.cn/problem/T166454">T166454 山峰和山谷</a></strong></p><p>可以发现，如果要判断 $i$ 是否是山峰 / 山谷，就必须要知道它的前面一个和后面一个。前面一个很好求，用一个变量记录下来就可以了。但是，后面一个该怎么求呢？</p><p>其实，我们只需要记录下来 $pre$（前一座山峰的高度）和 $pre2$ （前面第二座山峰的高度）即可。当循环到 $i$ 的时候，我们只需要判断 $pre$ 和 $pre2,  h_i$ 的大小关系即可。如果 $pre&lt;pre2,  h_i$ ，那么前面一座山峰是山谷。山峰也是同理。</p><p>注意要及时更改 $pre$ 和 $pre2$ 的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">pre=<span class="number">0</span>;pre2=<span class="number">0</span>;ans1=<span class="number">0</span>;ans2=<span class="number">0</span></span><br><span class="line"><span class="comment"># 通过分号把四条语句压到一行</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">    now=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">2</span> <span class="keyword">and</span> i&lt;=n): <span class="comment"># 先决条件,思考为什么是这样</span></span><br><span class="line">        <span class="keyword">if</span>(pre&gt;now <span class="keyword">and</span> pre&gt;pre2):</span><br><span class="line">            ans1=ans1+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(pre&lt;now <span class="keyword">and</span> pre&lt;pre2):</span><br><span class="line">            ans2=ans2+<span class="number">1</span></span><br><span class="line">    pre2=pre;pre=now</span><br><span class="line"><span class="built_in">print</span>(ans1,ans2)</span><br></pre></td></tr></table></figure><hr><p><strong>「 Problem 2 」<a href="https://www.luogu.com.cn/problem/P7285">「EZEC-5」修改数组</a></strong></p><p>证明：数组（ 假设为 $a$ ）中 $x-y$ 的最大值就是数组中 1 的个数。</p><p>因为每次修改 0 为 1 时， 最优情况 $x$ 和 $y$ 都会增加 1，所以 $x-y$ 的最大值即为数组中 1 的个数。</p><p>构造出这个方案也很简单——既然不管怎么样 $x$ 和 $y$ 都会增加 1，那就把整个数组全改为 1 即可。</p><p>下面这段代码过不去（ 输入输出被卡住了 ），但是意思相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> Test <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">    n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    ans=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">int</span>(<span class="built_in">input</span>())==<span class="number">1</span>): <span class="comment"># 统计1的个数</span></span><br><span class="line">            ans=ans+<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>): <span class="comment"># 输出方案(全为1)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><hr><p><strong>「 Problem 3 」<a href="https://www.luogu.com.cn/problem/P2415">P2415 集合求和</a></strong></p><p>我们考虑第 1 个数字会给整个和做出多少的贡献。<br>第一个数为答案做出的贡献即为第 1 个数字的大小 × 有多少个子集包含它。</p><p>我们发现，包含第一个数的子集，第 2-n 个数都可以任意选或不选，所以有 $2^{n-1}$ 个子集包含它。第二个，第三个，$\cdots\cdots$ ，第 $n$ 个也都是一样。</p><p>所以答案为 $\sum_{i=1}^ns_i\times2^{n-1}$ 。（所有数之和乘上 $2^{n-1}$）</p><p>下面这段代码过不去（ 输入输出被卡住了 ），但是意思相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">ans=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>): <span class="comment"># 统计和</span></span><br><span class="line">    ans=ans+<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n,<span class="number">1</span>): <span class="comment"># 乘方运算</span></span><br><span class="line">    ans=ans*<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><hr><ul><li><strong>循环嵌套</strong></li></ul><p>循环里面不仅可以套 if 语句，还可以在里面再套一个循环。比如，打印一个九九乘法表，你可以这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(i,<span class="string">&#x27;×&#x27;</span>,j,<span class="string">&#x27;=&#x27;</span>,i*j,end=<span class="string">&#x27;  &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>（ 请自行运行得到输出 ）</p><hr><p><strong>「 Problem 4 」<a href="https://www.luogu.com.cn/problem/T141821">T141821 表达式计算</a></strong></p><p>由于该题 过 于 简 单，这里直接给出代码：</p><p>（ 注意 Python 一秒钟最多运行 $10^7$ 次。 ）</p><p><strong>40pts</strong> /</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">ans=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,i+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">        ans=ans+j</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><p><strong>100pts (1)</strong> /</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">ans=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">    ans=ans+i*(n-i+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><p><strong>100pts (2)</strong> /</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">ans=<span class="number">0</span>;now=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">    now=now+i</span><br><span class="line">    ans=ans+now</span><br><span class="line"><span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><hr><p><strong>「 Problem 5 」<a href="https://www.luogu.com.cn/problem/P1255">P1255 数楼梯</a></strong></p><p>学过小学奥数的我们都知道，设 $f(i)$ 为上到第 $i$ 阶的走法，那么很容易得到 $f(i)=f(i-1)+f(i-2)$ 。跟Problem 1 一样，我们可以用变量 $pre$ 记录前一个的函数值，$pre2$ 记录前面第二个的函数值。</p><p>依旧要注意要及时更改 $pre$ 和 $pre2$ 的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>): <span class="built_in">print</span>(<span class="number">0</span>) <span class="comment"># 注意对特殊情况的判断</span></span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>): <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">2</span>): <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">2</span>):</span><br><span class="line">    pre=<span class="number">2</span>;pre2=<span class="number">1</span>;now=<span class="number">0</span> <span class="comment"># 思考pre和pre2的值为什么是这样</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,n+<span class="number">1</span>,<span class="number">1</span>): <span class="comment"># 思考为什么从3开始</span></span><br><span class="line">        now=pre+pre2</span><br><span class="line">        pre2=pre;pre=now</span><br><span class="line">    <span class="built_in">print</span>(now)</span><br></pre></td></tr></table></figure><hr><p><strong>「 Extra Problem 」<a href="https://www.luogu.com.cn/problem/SP8496">SP8496 No Squares Numbers</a></strong></p><p>这道题目中，我们可以发现 4 个循环：</p><ol><li>每一组数据为一个循环</li><li>$[a,b]$ 中的数为一个循环</li><li>对于数 $k$ ，枚举每个平方数看能不能整除它为一个循环</li><li>枚举每个数位，寻找数字 $c$ 为一个循环（ 这就需要将一个数字通过 <code>str()</code> 语句改变成字符串 ）</li></ol><p>完成这四个循环，需要你有一定的思维能力和代码能力。Have a try！</p><p>下面这段代码过不去（ 输入输出和时间被卡住了 ），但是意思相同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">for</span> test <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,t+<span class="number">1</span>,<span class="number">1</span>): <span class="comment"># 每一组数据为一个循环</span></span><br><span class="line">    a=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    b=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">    c=<span class="built_in">input</span>()</span><br><span class="line">    ans=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a,b+<span class="number">1</span>,<span class="number">1</span>): <span class="comment"># [a,b]中的数为一个循环</span></span><br><span class="line">        flag1=<span class="number">1</span></span><br><span class="line">        flag2=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">400</span>,<span class="number">1</span>): <span class="comment"># 枚举每个平方数看能不能整除它为一个循环</span></span><br><span class="line">            <span class="keyword">if</span>(j*j&lt;=i <span class="keyword">and</span> i%(j*j)==<span class="number">0</span>):</span><br><span class="line">                flag1=<span class="number">0</span></span><br><span class="line">        s=<span class="built_in">str</span>(i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> s: <span class="comment"># 枚举每个数位,寻找数字c为一个循环</span></span><br><span class="line">            <span class="keyword">if</span>(j==c):</span><br><span class="line">                flag2=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(flag1==<span class="number">1</span> <span class="keyword">and</span> flag2==<span class="number">1</span>):</span><br><span class="line">            ans=ans+<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><hr><p><strong>「 Practice Time 」</strong></p><ul><li><p><strong><a href="https://www.luogu.com.cn/problem/P5720">P5720 一尺之棰</a></strong></p><p><strong>提示</strong> / 如果想要退出 for 循环，可以用 <code>break</code> 。</p><p><strong>难度</strong> / 普及组 T1</p></li><li><p><strong><a href="https://www.luogu.com.cn/problem/P1317">P1317 低洼地</a></strong></p><p><strong>提示</strong> / 教材中有关于 “数组” 的部分知识。</p><p><strong>难度</strong> / 普及组 T2</p></li><li><p><strong><a href="https://www.luogu.com.cn/problem/P5723">P5723 质数口袋</a></strong></p><p><strong>提示</strong> / 如果 $n$ 是质数，那么 $[2,\sqrt{n}]$ 的数都不能整除它。</p></li></ul><blockquote><p>请注意和之前 if 语句的并列，break 语句和循环嵌套知识灵活运用。</p></blockquote><p>  <strong>难度</strong> / 普及组 T2-T3</p><ul><li><p><strong><a href="https://www.luogu.com.cn/problem/T166516">T166516 神奇的题目</a></strong></p><p><strong>提示</strong> / 想一想数学课上老师教过你什么知识。</p><p><strong>难度</strong> / 普及组 T2-T3</p></li><li><p><strong><a href="https://www.luogu.com.cn/problem/T166518">T166518 轩轩造题的五分钟</a></strong></p><p><strong>提示</strong> / 想一想这五个任务之间的联系。</p><p><strong>难度</strong> / 普及组 T2-T3</p></li><li><p><strong><a href="https://www.luogu.com.cn/training/102">「题单」循环结构</a></strong></p></li><li><p><strong><a href="https://www.luogu.com.cn/training/16120">「题单」循环基础</a></strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOI Online 游记</title>
      <link href="2021/05/16/noi-online-you-ji/"/>
      <url>2021/05/16/noi-online-you-ji/</url>
      
        <content type="html"><![CDATA[<p>期望得分：0+0+25=25pts</p><p>实际得分：0+0+25=25pts</p><span id="more"></span><h3 id="愤怒的小-N"><a href="#愤怒的小-N" class="headerlink" title="愤怒的小 N"></a>愤怒的小 N</h3><p><strong>预计得分</strong> : 0/100</p><p>我们设 $h(n)=(-1)^{pop(n)}$ , $pop(n)$ 为 $n$ 的二进制中 1 的奇偶性，$f(i)$ 是一个 $k$ 项多项式，请求出</p><script type="math/tex; mode=display">\frac{1}{2}\sum_{i=0}^{n-1} (1-h(i))f(i)</script><p>这是一个神奇的推式子题，但我不会做，我被区分了 /fad</p><hr><h3 id="积木小赛"><a href="#积木小赛" class="headerlink" title="积木小赛"></a>积木小赛</h3><p><strong>预计得分</strong> : 0/100</p><p>对于两个字符串 $S,T$ ，请求出使得 $S$ 的一个子序列等于 $T$ 的一个子串的方案数。</p><p>我们可以用 $O(n^2)$ 的时间复杂度找出一某个位置为开头，最后能够延展到的字符 $r_i$ 。对于这 $O(n^2)$ 个子串，可能会有一些是重复的，所以我们要比对他们的哈希值来判重。注意判重的时候不要用 map，常数较大，建议排序解决。另外，本题卡模数，常见的 998244353 会被卡，时间复杂度 $O(n^2\log n^2)$ 。</p><hr><h3 id="岛屿探险"><a href="#岛屿探险" class="headerlink" title="岛屿探险"></a>岛屿探险</h3><p><strong>预计得分</strong> : 25/100</p><p>有一个 $n$ 个数的数列 $p$ 和 $m$ 个询问 $q$ ，数列中第 $i$ 项包含两个值 $a$ , $b$ ，每个询问包含四个数 $l,r,c,d$ ，请求出在 $[l,r]$ 范围内满足 $(a\operatorname{xor} c)\le \min(b,d)$ 的项的个数，询问支持离线。</p><p>由于 $n$ 和 $m$ 同阶，时间复杂度统一用 $n$ 表示。$A$ 为值域，$A=(0,2^{24})$ 。</p><p><strong>20pts</strong> / 暴力枚举即可，时间复杂度 $O(n^2)$ 。</p><p><strong>35pts</strong> / 这一段满足 $\max(d)\le \min(b)$ ，我们可以提前把数列中每个数插入进 trie 树中，那么就形成了一棵 <strong>可持久化字典树</strong>。在可持久化字典树查找异或值 $\le d$ 的个数便是字典树的经典应用了。$O(n\log A)$</p><p><strong>55pts</strong> / 这一段满足 $\min(d)\ge \max(b)$ ，跟 35pts 的做法相似，我们可以发现满足 $(a\operatorname{xor} c)\le b$ 的 $c$ 值必然在 trie 树的几棵子树中，将这几科子树打上标记。处理询问时，模拟插入 $c$ 的过程算出答案即可。$O(n\log A)$</p><p><strong>65pts</strong> / 这一段满足 $l=1,r=n$ 。我们离线将所有询问和每一项按照 $b$ 或 $d$ 的大小升序排序。排序后，每个询问的前面利用 55pts 的方法，后面利用 35pts 的方法即可。$O(n\log A)$ </p><p><strong>80pts</strong> / 这一段满足 $n,q\le 7\times 10^4$ 。跟 65pts 的方法类似，我们可以将询问 <strong>分块</strong>。大块按照 65pts 的方法统一解决，散块直接暴力，时间复杂度 $O(n\log A+nB+\dfrac{n^2}{B}\log A)$ ，当取到 $B=\sqrt{n\log A}$ 时复杂度最优，最优为 $O(n\sqrt{n\log A})$ 。</p><p><strong>100pts</strong> / 这一段满足 $n,q\le 10^5$ 。考虑 <strong>CDQ分治</strong> （这是雅礼学长陈丹琦发明的算法，推荐！），考虑先将询问拆成 $qry(r)$ 和 $qry(l-1)$ 两部分，插进数列里按照下标排序。接着进行分治。分治内部再按照 $b$ 或 $d$ 的值排序，统计询问用 65pts 的思想，外加一棵 trie 树搞定。时间复杂度 $O(n\log^2n)$ 。</p><p><strong>Code</strong> : <a href="https://www.luogu.com.cn/paste/eedc46po">https://www.luogu.com.cn/paste/eedc46po</a> / <a href="https://www.luogu.com.cn/paste/gxm7yax4">https://www.luogu.com.cn/paste/gxm7yax4</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HNOI2021 游记</title>
      <link href="2021/05/16/hnoi2021-you-ji/"/>
      <url>2021/05/16/hnoi2021-you-ji/</url>
      
        <content type="html"><![CDATA[<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h3><p>晚上在机房颓废，<del>发现自己不会打线段树了</del></p><h3 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h3><p><del>提前 10min 发解压密码好评</del></p><p><del>发了 vimrc 文件好评</del></p><span id="more"></span><p>打开卷子，一看 T1，感觉自己点进了 B 卷。打的时候，越看越不对劲：</p><p>诶这个贪心好像假了？好像要奇奇怪怪的数据结构？貌似并不能二分下标？</p><p>这三个问题就直接把我问懵了。在 gedit 卡崩时的被迫冷静中，好像想到这个可以枚举最小值然后二分最大值？</p><p>感觉可以，直接开写。发现判断卡牌翻转次数的时候还需要一个二分，<del>由于我忘了 lower_bound</del>，只能够手写二分。时间复杂度 $O(n\log^2n)$，感觉要被卡常，加个最优性剪枝应该就可以了。</p><p>第二题只会 $b=0/1$ 的规律，第三题只会暴力，<del>我成功被区分了</del>。</p><p>理想得分 100+25+16=141，直接被吊打。</p><p>现实得分 100+0+16=116，真的被吊打了。</p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p><del>提前 20min 就发解压密码好评</del></p><p>看到这三道题的时候我直接傻眼了——为什么省选六道题会考四道图论？？？</p><p>T1 感觉暴力挺好打的样子。在我 <del>踢掉电源线</del> 的被迫冷静中，发现链的部分分好像可以用奇怪的启发式合并？</p><p>打完链对拍了一下，极限数据只有 0.3s 多，应该不会怎样。</p><p>T2 直接暴力，状压怎么想都想不出。（ 或许这道题不用状压？ ）</p><p>T3 的支配就是问你把那个点 $u$ 删掉之后 1 到 $v$ 之间是否还联通。暴力 bfs 应该会有 30pts。</p><p>然后开始考虑树上做法，其实跟 Tarjan 分横叉边和祖先子孙边那样分类讨论就行了。满分应该是 Tarjan 缩点？</p><p>理想得分 45+25+45=115，理想总分 $256=2^8$，感觉会被单调队列。</p><p>现实得分 25+25+30=80，总分 196pts，<del>d2t1出题人您为什么要造错数据</del></p><hr><p>奇怪的 T1 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn=<span class="number">1e6</span>,inf=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span> || ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;</span><br><span class="line">ch=<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">ch=<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,ans=inf;</span><br><span class="line"><span class="keyword">int</span> pre[Maxn+<span class="number">5</span>][<span class="number">2</span>],suf[Maxn+<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[Maxn+<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> y,<span class="keyword">int</span> opt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=n;</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">1</span>][<span class="number">0</span>]&gt;=y &amp;&amp; opt==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a[n][<span class="number">0</span>]&lt;=y &amp;&amp; opt==<span class="number">1</span>) <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid][<span class="number">0</span>]&lt;y) l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid][<span class="number">0</span>]&gt;y) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="built_in">Find</span>(x,<span class="number">-1</span>),r=<span class="built_in">Find</span>(mid,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(l&gt;<span class="number">0</span> &amp;&amp; (pre[l][<span class="number">0</span>]&lt;x || pre[l][<span class="number">1</span>]&gt;mid)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(r&lt;=n &amp;&amp; (suf[r][<span class="number">0</span>]&lt;x || suf[r][<span class="number">1</span>]&gt;mid)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> (l+n-r+<span class="number">1</span>)&lt;=m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Count</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l=x,r=<span class="built_in">min</span>(x+ans,inf);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Check</span>(x,r)==<span class="number">0</span>) <span class="keyword">return</span> inf;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Check</span>(x,mid)) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;card.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;card.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line"></span><br><span class="line">n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),pre[<span class="number">0</span>][<span class="number">0</span>]=suf[n+<span class="number">1</span>][<span class="number">0</span>]=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i][<span class="number">0</span>]=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i][<span class="number">1</span>]=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">pre[i][<span class="number">0</span>]=<span class="built_in">min</span>(pre[i<span class="number">-1</span>][<span class="number">0</span>],a[i][<span class="number">1</span>]),</span><br><span class="line">pre[i][<span class="number">1</span>]=<span class="built_in">max</span>(pre[i<span class="number">-1</span>][<span class="number">1</span>],a[i][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">suf[i][<span class="number">0</span>]=<span class="built_in">min</span>(suf[i+<span class="number">1</span>][<span class="number">0</span>],a[i][<span class="number">1</span>]),</span><br><span class="line">suf[i][<span class="number">1</span>]=<span class="built_in">max</span>(suf[i+<span class="number">1</span>][<span class="number">1</span>],a[i][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1</span>;++j)</span><br><span class="line">ans=<span class="built_in">min</span>(ans,<span class="built_in">Count</span>(a[i][j]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈树状数组 &amp; 线段树</title>
      <link href="2021/05/15/qian-tan-shu-zhuang-shu-zu-and-xian-duan-shu/"/>
      <url>2021/05/15/qian-tan-shu-zhuang-shu-zu-and-xian-duan-shu/</url>
      
        <content type="html"><![CDATA[<p>树状数组和线段树是最基础的区间数据结构之一，它也成为了很多 OIer 数据结构方面 “梦开始的地方”。它们通过预处理 / 维护特定的子区间信息来平衡修改和查询时间复杂度，变成 $O(n\log n)$。很多数据结构存储的方式都跟 “树” 有关，所以名字也通常带有树这个字。</p><span id="more"></span><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol><li>前言<ul><li>难度等级介绍</li><li>真正的前言</li></ul></li><li>树状数组<ul><li>树状数组介绍</li><li>单点修改操作的实现</li><li>区间查询操作的实现</li><li>Code</li><li>经典练习</li></ul></li><li>线段树<ul><li>线段树介绍</li><li>存储及建树的实现</li><li>懒惰标记介绍</li><li>区间修改，查询的实现</li><li>Code</li><li>经典练习</li></ul></li></ol><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在这一篇及之后的博客中，将会设立<strong>难度等级</strong>这个东西。难度分为五种：</p><p>$\color{grey}{Easy}$ , $\color{orange}{Normal}$ , $\color{blue}{Hard}$ , $\color{green}{Expert}$ , $\color{red}{Impossible}$ 。</p><p>同时，每种难度还可以加上附带标签 $+$ 和 $-$  。</p><p>进入正题：</p><p>有一句名言：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">树状数组能做的，线段树都能做。</span><br><span class="line">树状数组不能做的，线段树甚至也可以做。</span><br></pre></td></tr></table></figure><p>而且，树状数组和线段树的时间复杂度都是一样的（ 均为 $O(n\log_2n)$ ），那么，我们为什么要学习树状数组呢？</p><p>两个原因：</p><ol><li>树状数组比线段树常数小多了</li><li>树状数组比线段树码量小多了</li></ol><hr><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><p>看完前言之后，你是不是依然不知道这两个东西是干什么的呢？</p><p>它们都是用来解决<strong>序列操作问题</strong>的。</p><p>以 <a href="https://www.luogu.com.cn/problem/P3374">这道题</a> 为例，它需要我们实现单点修改，区间查询的功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注：</span><br><span class="line">序列操作问题一共有四种，分别为：</span><br><span class="line">1. 单点修改，单点查询</span><br><span class="line">2. 单点修改，区间查询</span><br><span class="line">3. 区间修改，单点查询</span><br><span class="line">4. 区间修改，区间查询</span><br></pre></td></tr></table></figure><p>看到这里你可能会疑惑：</p><p>——我觉得树状数组应该是处理树上问题的啊！</p><p>其实，它是将序列内的一些信息存储在了一棵树上面。</p><p>like this :</p><p><img src="https://s1.ax1x.com/2020/05/03/JzpMdS.png" alt="JzpMdS.png"></p><p>这是用一棵树来存储序列 $[ 1 , 10 ]$ 的一个例子。</p><p>树上各个结点中有两个数 $l , r$ ，表示它存储的是区间 $[ l , r ]$ 的信息。</p><hr><p>而<strong>树状数组</strong>，则是把这一棵树重新压缩成了数组，像这样：</p><p><img src="https://s1.ax1x.com/2020/05/03/JzpBi4.png" alt="JzpBi4.png"></p><ul><li><p>其中的第 8 号位置，存储了区间 $[1 , 8]$ 的信息；</p></li><li><p>其中的第 4 号位置，存储了区间 $[1 , 4]$ 的信息；</p></li><li><p>其中的第 6 号结点，存储了区间 $[5 , 6]$ 的信息；</p></li></ul><p>$\cdots\cdots$ 以此类推。</p><p>有同学可能又会问：</p><p>——每个结点下面标记它们的二进制干什么？</p><p>稍后揭晓。</p><hr><p>我们再来看一遍 <a href="https://www.luogu.com.cn/problem/P3374">模板题</a> 吧。</p><p>先来实现<strong>单点修改</strong>的操作。</p><p>很明显，这棵树状数组存储的区间内的信息是它的<strong>区间和</strong>。</p><p>由图得：</p><p>如果需要修改第 $t$ 个数，则需要先修改树状数组内的 $t$ 号结点，再修改它的父亲，再修改它的父亲的父亲，$\cdots\cdots$ ，直至最上方的根结点。</p><hr><p>该如何修改呢？</p><p>我们来找一下父子结点的规律吧。</p><p>再次把图放一遍：</p><p><img src="https://s1.ax1x.com/2020/05/03/JzpBi4.png" alt="JzpBi4.png"></p><p>$4 \to 8 , (100) \to (1000)$</p><p>$6 \to 8 , (110) \to (1000)$</p><p>$3 \to 4 , (011) \to (100)$</p><p>找到什么规律了吗？</p><p>某个结点的编号（ 这里令它为 $x$ ）加上它的 <strong>lowbit</strong> （ 它二进制表达式中最低位的 1 所对应的值 ）就是它的父结点编号了！</p><p>那么该怎么求出 $lowbit(x)$ 呢？</p><p>给出一个公式：$lowbit(x)=x\&amp;-x$ （ 原理请自行查找 ）</p><p>$\&amp;$ 这个符号代表 C++ 中的 <strong>与运算</strong> 。</p><p>与运算含义：两个数经过与运算生成第三个数，这两个数的二进制某位都为 1，第三个数的二进制那一位才为 1</p><hr><p>这样子，我们就可以写出单点修改的代码了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxn (int)1e5*5</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> t[Maxn+<span class="number">1</span>];<span class="comment">//树状数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//单点修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line">t[x]+=y;</span><br><span class="line">x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>接下来是区间查询：</p><p>我们还是把那张图放一遍：</p><p><img src="https://s1.ax1x.com/2020/05/03/JzpBi4.png" alt="JzpBi4.png"></p><p>如何进行区间的查询呢？</p><p>假如要查询 $[1,7]$ 和，我们可以这么跳：</p><p><img src="https://s1.ax1x.com/2020/05/03/JzCJbV.png" alt="JzCJbV.png"></p><p>我们可以发现，树状数组可以查询 $[1,1] , [1,2] , \cdots , [1,n]$ 的区间。</p><p>那么对于区间 $[l,r]$ 呢？</p><p>我们可以这样做：$ans_{[l,r]}=ans_{[1,r]}-ans_{[1,l-1]}$</p><p>这就运用了<strong>前缀和</strong>的原理。</p><p>那我们如何实现 ”跳跃“ 这个操作呢？</p><p>$7 \to 6 , (111) \to (110)$</p><p>$6 \to 4 , (110) \to (100)$</p><p>其实，对于编号为 $x$ 的结点，只要减去 $lowbit(x)$ 就可以实现 ”往上跳“ 这个操作了。</p><hr><p>代码时间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//查询前缀和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)</span><br><span class="line">&#123;</span><br><span class="line">cnt+=t[x];</span><br><span class="line">x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>此时，<a href="https://www.luogu.com.cn/problem/P3374">模板题</a> 已经可以成功的 AC 了：（ 难度：$\color{orange}{Normal}$ ） </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxn (int)1e5*5</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> t[Maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line">t[x]+=y;</span><br><span class="line">x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)</span><br><span class="line">&#123;</span><br><span class="line">cnt+=t[x];</span><br><span class="line">x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"><span class="built_in">Update</span>(i,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> typ,x,y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;typ,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(typ==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Update</span>(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(typ==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Search</span>(y)-<span class="built_in">Search</span>(x<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>一些经典的树状数组练习题：</p><ol><li><a href="https://www.luogu.com.cn/problem/P3368">P3368 【模板】 树状数组 2</a></li><li><a href="https://www.luogu.com.cn/problem/P4939">P4939 Agent2</a></li><li><a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对</a></li><li><a href="https://www.luogu.com.cn/problem/AT2829">AT2829 転倒数</a></li><li><a href="https://www.luogu.com.cn/problem/P1168">P1168 中位数</a></li></ol><p>（ 注：这些题目或多或少都结合了其它的知识，需要放开自己的思维去寻找答案 ）</p><hr><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>它又是个什么东西？</p><p>回顾一下这一张图片吧：</p><p><img src="https://s1.ax1x.com/2020/05/03/JzpMdS.png" alt="JzpMdS.png"></p><p><strong>线段树</strong>跟树状数组类似，只不过它<strong>直接存储了这棵树</strong>。</p><p>它是一棵二叉树。某些特殊的二叉树（ 比如线段树 ）有一个特点：</p><p>假设根结点编号为 1， </p><p>某个父亲结点的编号为 $x$ ，</p><p>则它的儿子结点编号为 $x\cdot2$ 和 $x \cdot 2 +1$ 。（ 证明略 ）</p><p>这样，我们只需要一个数组就可以存储整棵树了！多么 delicious ！</p><hr><p>这样，我们就可以写出 <a href="https://www.luogu.com.cn/problem/P3372">模板题</a> 的第一部分了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxn int(1e5)</span></span><br><span class="line"></span><br><span class="line">ll num[Maxn+<span class="number">5</span>],t[(Maxn&lt;&lt;<span class="number">2</span>)+<span class="number">5</span>];<span class="comment">//原数组和线段树组，注意线段树要开四倍空间</span></span><br><span class="line">ll n,m;</span><br></pre></td></tr></table></figure><hr><p>接下来，考虑建树：</p><p>由于一个结点 $x$ 的左儿子为 $x\cdot2$ （ 用 C++ 位运算表示为 $x&lt;&lt;1$ ），</p><p> 右儿子为 $x\cdot2+1$ （ 用 C++ 位运算表示为 $x&lt;&lt;1|1$ ），</p><p>我们就可以写出两个宏定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) (x&lt;&lt;1|1)</span></span><br></pre></td></tr></table></figure><p>同时，我们为了获取一个区间的信息，我们就需要合并它右节点的信息和左节点的信息，（模板题的信息指的是区间和），我们就需要一个 <code>push_up</code> （ 即上传 ）操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll p)</span><span class="comment">//上传 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[p]=t[<span class="built_in">ls</span>(p)]+t[<span class="built_in">rs</span>(p)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们采用<strong>递归建树</strong>的方式来建好整棵树，时间复杂度为 $O(n\log_2n)$ 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(ll l,ll r,ll p)</span><span class="comment">//构建线段树 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)<span class="comment">//如果到了底层结点</span></span><br><span class="line">&#123;</span><br><span class="line">t[p]=num[l];<span class="comment">//获取信息</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll mid=(l+r)&gt;&gt;<span class="number">1</span>;<span class="comment">//找到中间点</span></span><br><span class="line"><span class="built_in">Build</span>(l,mid,<span class="built_in">ls</span>(p));<span class="comment">//递归建好左子树</span></span><br><span class="line"><span class="built_in">Build</span>(mid+<span class="number">1</span>,r,<span class="built_in">rs</span>(p));<span class="comment">//递归建好右子树</span></span><br><span class="line"><span class="built_in">push_up</span>(p);<span class="comment">//上传信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>接下来完成<strong>区间修改</strong>的操作：</p><p>首先考虑暴力修改法：</p><ol><li>暴力 dfs 整棵树</li><li>当遇到当前区间包含待修改区间的情况时，修改该区间信息</li></ol><p>照这样做，单次修改的时间复杂度就到了 $O(n\log_2n)$ ，并不优秀。</p><p>我们尝试着把这种修改方法改一下：</p><p>我们可以引入一个叫做 <strong>lazy tag</strong> （ 懒惰标记 ）的东西，区间修改的时候，我们就可以这样：</p><p>（ 选自 <a href="https://oi-wiki.org/ds/seg/">OI-Wiki</a> ）</p><p><img src="https://s1.ax1x.com/2020/05/04/YCi540.png" alt="YCi540.png"></p><p><a href="https://imgchr.com/i/YCiT3T"><img src="https://s1.ax1x.com/2020/05/04/YCiT3T.png" alt="YCiT3T.png"></a></p><p><a href="https://imgchr.com/i/YCiqu4"><img src="https://s1.ax1x.com/2020/05/04/YCiqu4.png" alt="YCiqu4.png"></a></p><p><img src="https://s1.ax1x.com/2020/05/04/YCivU1.png" alt="YCivU1.png"></p><p><a href="https://imgchr.com/i/YCFSC6"><img src="https://s1.ax1x.com/2020/05/04/YCFSC6.png" alt="YCFSC6.png"></a></p><p>不过，欠的东西总是要还的，所以我们还需要实现 lazy tag 的<strong>下传</strong> 操作：</p><p><img src="https://s1.ax1x.com/2020/05/04/YCF2RK.png" alt="YCF2RK.png"></p><p><img src="https://s1.ax1x.com/2020/05/04/YCFfMD.png" alt="YCFfMD.png"></p><p><img src="https://s1.ax1x.com/2020/05/04/YCFodA.png" alt="YCFodA.png"></p><p>这样，我们就可以编写出 lazy tag 的 <strong>下传</strong> 操作了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(ll s,ll p,ll k)</span><span class="comment">//计算 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tag[p]+=k;</span><br><span class="line">t[p]=t[p]+s*k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(ll l,ll r,ll p)</span><span class="comment">//下传 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">f</span>(mid-l+<span class="number">1</span>,<span class="built_in">ls</span>(p),tag[p]);</span><br><span class="line"><span class="built_in">f</span>(r-mid,<span class="built_in">rs</span>(p),tag[p]);</span><br><span class="line">tag[p]=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>修改操作也迎刃而解了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(ll nl,ll nr,ll l,ll r,ll p,ll k)</span><span class="comment">//修改 </span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//nl,nr:当前区间左右端点</span></span><br><span class="line"><span class="keyword">if</span>(l&lt;=nl &amp;&amp; nr&lt;=r)</span><br><span class="line">&#123;<span class="comment">//如果当前区间与待修改区间有包含关系</span></span><br><span class="line">t[p]+=k*(nr-nl+<span class="number">1</span>);<span class="comment">//修改信息</span></span><br><span class="line">tag[p]+=k;<span class="comment">//添加lazy tag</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">push_down</span>(nl,nr,p);<span class="comment">//下传</span></span><br><span class="line">ll mid=(nl+nr)&gt;&gt;<span class="number">1</span>;<span class="comment">//递归进行修改</span></span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">Update</span>(nl,mid,l,r,<span class="built_in">ls</span>(p),k);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) <span class="built_in">Update</span>(mid+<span class="number">1</span>,nr,l,r,<span class="built_in">rs</span>(p),k);</span><br><span class="line"><span class="built_in">push_up</span>(p);<span class="comment">//上传</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>接下来，就是<strong>区间查询</strong>了，其实跟区间修改的代码差不多：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">Count</span><span class="params">(ll nl,ll nr,ll l,ll r,ll p)</span><span class="comment">//查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=nl &amp;&amp; nr&lt;=r)</span><br><span class="line">&#123;<span class="comment">//如果当前区间与待修改区间有包含关系</span></span><br><span class="line"><span class="keyword">return</span> t[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">push_down</span>(nl,nr,p);<span class="comment">//下传</span></span><br><span class="line">ll mid=(nl+nr)&gt;&gt;<span class="number">1</span>,cnt=<span class="number">0</span>;<span class="comment">//cnt统计结果</span></span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) cnt+=<span class="built_in">Count</span>(nl,mid,l,r,<span class="built_in">ls</span>(p));<span class="comment">//递归查询</span></span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) cnt+=<span class="built_in">Count</span>(mid+<span class="number">1</span>,nr,l,r,<span class="built_in">rs</span>(p));</span><br><span class="line"><span class="built_in">push_up</span>(p);<span class="comment">//上传</span></span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://www.luogu.com.cn/problem/P3372">模板题</a> 完整代码：（ 难度：$\color{orange}{Normal+}$ ）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxn int(1e5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) (x&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ll num[Maxn+<span class="number">5</span>],tag[(Maxn&lt;&lt;<span class="number">2</span>)+<span class="number">5</span>],t[(Maxn&lt;&lt;<span class="number">2</span>)+<span class="number">5</span>];</span><br><span class="line">ll n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(ll p)</span><span class="comment">//上传 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">t[p]=t[<span class="built_in">ls</span>(p)]+t[<span class="built_in">rs</span>(p)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(ll s,ll p,ll k)</span><span class="comment">//计算 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tag[p]+=k;</span><br><span class="line">t[p]=t[p]+s*k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(ll l,ll r,ll p)</span><span class="comment">//下传 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">f</span>(mid-l+<span class="number">1</span>,<span class="built_in">ls</span>(p),tag[p]);</span><br><span class="line"><span class="built_in">f</span>(r-mid,<span class="built_in">rs</span>(p),tag[p]);</span><br><span class="line">tag[p]=<span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(ll l,ll r,ll p)</span><span class="comment">//构建线段树 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">t[p]=num[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">Build</span>(l,mid,<span class="built_in">ls</span>(p));</span><br><span class="line"><span class="built_in">Build</span>(mid+<span class="number">1</span>,r,<span class="built_in">rs</span>(p));</span><br><span class="line"><span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(ll nl,ll nr,ll l,ll r,ll p,ll k)</span><span class="comment">//修改 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=nl &amp;&amp; nr&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">t[p]+=k*(nr-nl+<span class="number">1</span>);</span><br><span class="line">tag[p]+=k;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">push_down</span>(nl,nr,p);</span><br><span class="line">ll mid=(nl+nr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">Update</span>(nl,mid,l,r,<span class="built_in">ls</span>(p),k);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) <span class="built_in">Update</span>(mid+<span class="number">1</span>,nr,l,r,<span class="built_in">rs</span>(p),k);</span><br><span class="line"><span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Count</span><span class="params">(ll nl,ll nr,ll l,ll r,ll p)</span><span class="comment">//查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=nl &amp;&amp; nr&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> t[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">push_down</span>(nl,nr,p);</span><br><span class="line">ll mid=(nl+nr)&gt;&gt;<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) cnt+=<span class="built_in">Count</span>(nl,mid,l,r,<span class="built_in">ls</span>(p));</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) cnt+=<span class="built_in">Count</span>(mid+<span class="number">1</span>,nr,l,r,<span class="built_in">rs</span>(p));</span><br><span class="line"><span class="built_in">push_up</span>(p);</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> ll i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;num[i]);</span><br><span class="line"><span class="built_in">Build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> ll i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">&#123;</span><br><span class="line">ll typ,x,y,z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;typ,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(typ==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;z);</span><br><span class="line"><span class="built_in">Update</span>(<span class="number">1</span>,n,x,y,<span class="number">1</span>,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(typ==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">Count</span>(<span class="number">1</span>,n,x,y,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>一些经典的线段树练习题：</p><ol><li><a href="https://www.luogu.com.cn/problem/P1531">P1531 I Hate It</a></li><li><a href="https://www.luogu.com.cn/problem/P2357">P2357 守墓人</a></li><li><a href="https://www.luogu.com.cn/problem/P2574">P2574 XOR的艺术</a></li><li><a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 / 【模板】单调队列</a></li></ol><p>同时，这道题 <a href="https://www.luogu.com.cn/problem/U113718">U113718 经典序列问题三合一</a> 的前两问可以使用树状数组和线段树来完成！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 FHQ-Treap</title>
      <link href="2021/05/15/qian-tan-fhq-treap/"/>
      <url>2021/05/15/qian-tan-fhq-treap/</url>
      
        <content type="html"><![CDATA[<p>FHQ-Treap 是平衡树的一种，它是一种无需旋转的平衡树，这也使得它能够高效快速地支持区间操作和可持久化。平衡树结点有两种类型，权值 $val$ 和随机权值 $key$。FHQ-Treap 让权值满足二叉搜索树的性质，而让随机权值满足堆性质，从而保证 $O(n\log n)$ 的时间复杂度。</p><span id="more"></span><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol><li><p>前言</p><ul><li>FHQ - Treap 介绍</li><li>优缺点介绍</li></ul></li><li><p>实现方法</p><ul><li><p>基础操作</p></li><li><p>Split &amp; Merge</p></li><li>其它操作</li></ul></li><li><p>区间问题</p><ul><li>Split &amp; Merge ( New )</li><li>提取，翻转与合并区间</li></ul></li></ol><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>FHQ-Treap 介绍</li></ul><p>FHQ-Treap 是一种可以不用旋转的，类似 Treap 的东西。跟 Treap 一样，每个结点不仅有一个权值（ val ），还有一个随机索引（ key ）。它的权值组成了二叉搜索树，而索引则组成了一个小根堆。</p><p>因为这种性质，这棵树就保证了平衡。它通过两个关键操作—— <strong>分裂（ Split ）</strong> 和 <strong>合并（ Merge ）</strong> 来完成树的平衡和各种操作。</p><hr><ul><li>优缺点介绍</li></ul><p><strong>优点</strong> / 代码简单，常数较小（ 指比 Splay 小 ），支持可持久化和区间操作</p><p><strong>缺点</strong> / 作为 LCT 辅助树时总时间复杂度 $O(n\log^2n)$ </p><hr><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>基础操作</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,val;</span><br><span class="line">    <span class="keyword">int</span> key,siz;</span><br><span class="line">&#125; k[Maxn+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n,tot,root;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(x) k[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(x) k[x].r</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Newnode</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// 创建新结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    k[++tot]=(Node)&#123;<span class="number">0</span>,<span class="number">0</span>,x,<span class="built_in">rand</span>(),<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">// 上传</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    k[x].siz=k[<span class="built_in">ls</span>(x)].siz+k[<span class="built_in">rs</span>(x)].siz+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>Split &amp; Merge</li></ul><p>FHQ-Treap 最核心的操作就是 Split 和 Merge 。Split 是将一棵树按照某个权值 $val$ 将它分裂成 $\le val$ 和 $&gt; val$ 的两部分，且依然符合平衡树的性质。Merge 是将两棵树（ 假设为 $x,y$ ，且 $x$ 树中所有权值均不大于 $y$ 树中所有权值 ）合并成为一棵树，也依然符合平衡树的性质。</p><p>这是一棵平衡树：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9gcwn3ks.png" alt=""></p><p>我们把它以 26 这个值分裂后，变成了这样：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/sx15doye.png" alt=""></p><p>按照 11 这个值分裂则是这样：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/keqhvx7t.png" alt=""></p><p>根据分裂的过程可以发现，Split 函数的大作步骤如下：</p><ol><li>判断根节点与分裂值 $val$ 的大小关系。（ 后面以如果小于等于它为例，大于它则相反 ）</li><li>将根节点设为第一棵树的根。</li><li>对右子树递归进行 Split 操作，将它分裂为 $\le val$ 和 $&gt;val$ 的两部分，第一部分接在右子树，第二部分则成为新的一棵树。</li></ol><p>递归终止条件：当前根节点为 0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> val,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span> <span class="comment">// 分裂为x和y两部分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now) &#123;x=y=<span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(k[now].val&lt;=val)</span><br><span class="line">        x=now,<span class="built_in">Split</span>(<span class="built_in">rs</span>(now),val,<span class="built_in">rs</span>(now),y);</span><br><span class="line">    <span class="keyword">if</span>(k[now].val&gt;val)</span><br><span class="line">        y=now,<span class="built_in">Split</span>(<span class="built_in">ls</span>(now),val,x,<span class="built_in">ls</span>(now));</span><br><span class="line">    <span class="built_in">Update</span>(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Merge 操作的两棵树 $x$ 和 $y$ ，合并起来只有这两种情况：</p><ol><li><p>$key_x\le key_y$ <img src="https://cdn.luogu.com.cn/upload/image_hosting/3fr1sd65.png" alt=""></p></li><li><p>$key_y&lt;key_x$<img src="https://cdn.luogu.com.cn/upload/image_hosting/axeb12ko.png" alt=""></p></li></ol><p>所以我们就可以得出 Merge 操作大致的过程了：</p><ol><li>判断 $key_x$ 与 $key_y$ 的大小关系（ 以第一种情况为例，大于它则相反 ）</li><li>对右子树进行递归操作，即合并它的右子树和树 $y$ ，并将合并后的根成为它的右儿子</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="comment">// 合并 x,y 返回新根</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k[x].key&lt;=k[y].key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">rs</span>(x)=<span class="built_in">Merge</span>(<span class="built_in">rs</span>(x),y),<span class="built_in">Update</span>(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ls</span>(y)=<span class="built_in">Merge</span>(x,<span class="built_in">ls</span>(y)),<span class="built_in">Update</span>(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，接下来的所有操作，都可以用这两个核心操作完成了。</p><hr><ul><li>其它操作</li></ul><p>根据 Split 和 Merge 操作的含义感性理解即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入新结点，权值为 x</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    x=<span class="built_in">Newnode</span>(x);</span><br><span class="line">    <span class="built_in">Split</span>(root,k[x].val,a,b);</span><br><span class="line">    root=<span class="built_in">Merge</span>(a,<span class="built_in">Merge</span>(x,b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除值为 x 的一个结点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">Split</span>(root,x<span class="number">-1</span>,a,b),<span class="built_in">Split</span>(b,x,b,c);</span><br><span class="line">    root=<span class="built_in">Merge</span>(a,<span class="built_in">Merge</span>(<span class="built_in">Merge</span>(<span class="built_in">ls</span>(b),<span class="built_in">rs</span>(b)),c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询 x 的排名</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Rate</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,res;</span><br><span class="line">    <span class="built_in">Split</span>(root,x<span class="number">-1</span>,a,b);</span><br><span class="line">    res=k[a].siz+<span class="number">1</span>;</span><br><span class="line">    root=<span class="built_in">Merge</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询第 x 名</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Kth</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now=root;</span><br><span class="line">    <span class="keyword">while</span>(now)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> siz=k[<span class="built_in">ls</span>(now)].siz+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(siz==x) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(siz&gt;x) now=<span class="built_in">ls</span>(now);</span><br><span class="line">        <span class="keyword">else</span> x-=siz,now=<span class="built_in">rs</span>(now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k[now].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询 x 的前驱</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pre</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,now;</span><br><span class="line">    <span class="built_in">Split</span>(root,x<span class="number">-1</span>,a,b);</span><br><span class="line">    now=a; <span class="keyword">while</span>(<span class="built_in">rs</span>(now)) now=<span class="built_in">rs</span>(now);</span><br><span class="line">    root=<span class="built_in">Merge</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> k[now].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询 x 的后继</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Nxt</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,now;</span><br><span class="line">    <span class="built_in">Split</span>(root,x,a,b);</span><br><span class="line">    now=b; <span class="keyword">while</span>(<span class="built_in">ls</span>(now)) now=<span class="built_in">ls</span>(now);</span><br><span class="line">    root=<span class="built_in">Merge</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> k[now].val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板代码</strong> / <a href="https://www.luogu.com.cn/paste/uswxlq5c"><strong>There</strong></a></p><hr><h3 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h3><p>在解决区间问题时，平衡树中某一结点左端的结点在原序列中都比它靠前，右端的结点都比它靠后。也就是说，这棵平衡树的 <strong>中序遍历</strong> 即为原序列。</p><ul><li>Split &amp; Merge ( New )</li></ul><p>Split 改变为将某棵树中前 $siz$ 个结点放到一个树中，后面的结点放到另一棵树。Merge 操作则不变，只不过 $x$ 树中所有的位置都要比 $y$ 树中所有位置靠前。注意区间平衡树涉及到下传标记这一过程，所以要当子树可能产生改变的位置进行下传操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Split</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> siz,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now) &#123;x=y=<span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="built_in">push_down</span>(now);</span><br><span class="line">    <span class="keyword">if</span>(t[<span class="built_in">ls</span>(now)].siz+<span class="number">1</span>&lt;=siz)</span><br><span class="line">        x=now,<span class="built_in">Split</span>(<span class="built_in">rs</span>(now),siz-t[<span class="built_in">ls</span>(now)].siz<span class="number">-1</span>,<span class="built_in">rs</span>(now),y);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y=now,<span class="built_in">Split</span>(<span class="built_in">ls</span>(now),siz,x,<span class="built_in">ls</span>(now));</span><br><span class="line">    <span class="built_in">Update</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x+y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t[x].key&lt;=t[y].key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">push_down</span>(x);</span><br><span class="line">        <span class="built_in">rs</span>(x)=<span class="built_in">Merge</span>(<span class="built_in">rs</span>(x),y),<span class="built_in">Update</span>(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">push_down</span>(y);</span><br><span class="line">        <span class="built_in">ls</span>(y)=<span class="built_in">Merge</span>(x,<span class="built_in">ls</span>(y)),<span class="built_in">Update</span>(y);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li>提取，翻转与合并区间</li></ul><p>对于区间翻转操作，可以利用平衡树的两个核心操作 Split 和 Merge 提取出这个区间对应的树，将每个结点的左右儿子交换即可。对于交换左右儿子的操作，我们可以在根节点打上翻转标记，并在适当的时候进行下传。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t[x].tag) <span class="keyword">return</span>;</span><br><span class="line">    t[x].tag=<span class="number">0</span>,<span class="built_in">swap</span>(<span class="built_in">ls</span>(x),<span class="built_in">rs</span>(x));</span><br><span class="line">    t[<span class="built_in">ls</span>(x)].tag^=<span class="number">1</span>,t[<span class="built_in">rs</span>(x)].tag^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">Split</span>(root,r,a,c),<span class="built_in">Split</span>(a,l<span class="number">-1</span>,a,b);</span><br><span class="line">    t[b].tag^=<span class="number">1</span>;</span><br><span class="line">    root=<span class="built_in">Merge</span>(a,<span class="built_in">Merge</span>(b,c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模板代码</strong> / <a href="https://www.luogu.com.cn/paste/6aojh6oz"><strong>There</strong></a></p><hr><h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><ol><li><a href="https://www.luogu.com.cn/problem/P1486"><strong>P1486 「NOI2004」 郁闷的出纳员</strong></a></li><li><a href="https://www.luogu.com.cn/problem/P2286"><strong>P2286 「HNOI2004」宠物收养场</strong></a></li><li><a href="https://www.luogu.com.cn/problem/P3224"><strong>P3224 「HNOI2012」永无乡</strong></a></li><li><a href="https://www.luogu.com.cn/problem/P4036"><strong>P4036 「JSOI2008」火星人</strong></a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
